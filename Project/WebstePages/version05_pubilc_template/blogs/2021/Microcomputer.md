# 8086

# 第一章 绪论

```markdown
8086 ——16位处理器
数据总线DB——16位
地址总线AB——20位
```

## 存储器
**内存的读步骤**

``` markdown
1.CPU把要读的内存单元的地址放到AB上
2. CPU发出读命令
3. 内存将数据从指定单元读到DB上
4. CPU从DB上取回数据
```

**内存的写操作**

``` markdown
1. CPU把要写的内存单元的地址放到AB上
2. CPU把要写的数据放到DB上
3. CPU发出写的命令
4. 数据被内存写到指定的单元
```
```markdown
外存中的数据使用前必须先读到内存中，然后CPU才能访问
```


## 总线

```markdown
总线宽度：一次可以同时传输的数据位数
8086，数据总线宽度为16位，地址总线宽度位20位
```

## IO

## 溢出
```markdown
异号相加不会溢出
同号相加可能溢出
```

## 二进制

## BCD码

``` markdown
用二进制编码表示十进制数
一位十进制数需要用四位二进制编码表示
压缩BCD码——一个字节表示两位十进制数
非压缩BCD码——一个字节表示一位十进制数（使用低四位）
```



# 第二章 8086

## 性能指标

```markdown
字长——CPU能够同时处理的数据的位数，也称为数据位宽
8086——16位
主频——时钟频率
```



## 8086的编程结构

``` markdwon
16位数据线；
20位地址线——寻址空间:1MB（2^20）
寄存器：数值逻辑部件，用来暂存数码和信息；由触发器和门电路阻成；
```



## **总线接口部件BIU**

### 功能
```markdown
1. 从内存取指令到指令队列
2. CPU执行指令时，BIU配合执行部件从指定内存单元或外设端口中取数据，将数据传送给执行部件
3. BIU配合执行部件把操作结果传送到指定的内存单元或外设接口
```

### 组成

``` markdown
a) 16位段地址寄存器（sgement）——4个
    i) CS CODE
    ii) DS DATA
    iii) ES EXTRA	
    iv) SS STACK
b) 16位指令指针寄存器——IP（instruction pointer）
c) 20位地址加法器
    i) 用来产生20位的地址
        One. 8086用20位地址寻址1MB的内存，但是8086内部的寄存器都是16位的
        Two. 地址加法器就是根据16位寄存器提供的信息计算出20位的物理地址
            First. CS左移四位再与IP相加
d) 6字节的指令队列缓冲器
    i) 指令队列缓冲器——CPU在执行指令的同时，从内存中取下面一条指令或几条指令放在指令队列中


```
### BIU的执行方式
``` markdown
| 顺序执行方式：功能部件交替工作，按顺序完成指令的执行过程
| 并行流水线方式：各功能部件并行工
```
## **执行部件EU**

### 组成

```markdown
算数逻辑部件ALU

16位的通用寄存器——4个

    AX——累加器

    BX

    CX

    DX

		16位通用寄存器可以当作8位来使用，高八位和低八位

16位的专用寄存器——4个

    BP——BASE POINTER基数指针寄存器
    SP——STACK POINTER堆栈指针寄存器
    SI——SOURCE INDEX源变址寄存器
    DI——DESTINATION           INDEX目的变址寄存器。

16位标志寄存器——九个使用，七个未用

状态标志位——6个

    | SF   | Sign flag            | 符号标志       | 与运算结果的最高位相同，运算结果为正数SF=0,运算结果为负数，SF=1
    | ZF   | Zero flag            | 零标志         | 运算结果为0，ZF=1，运算结果为非零，ZF=0 
    | PF   | Parity flag          | 奇/偶标志位    | 运算结果中，低八位中所含1的个数为偶数，PF=1；低八位中所含1的个数为奇数，PF=0
    | CF   | Carry flag           | 进位标志位     | 加法运算——最高位产生进位，CF=1；减法运算——最高位产生借位,CF=1
    | AF   | Auxiliary carry flag | 辅助进位标志位 | 加法运算——第三位往第四位进位，AF=1；减法运算——第三位从第四位借位，AF=1
    | OF   | Overflow flage       | 溢出标志位     | 产生溢出——OF=1

控制标志位——3个

    | DF   | Direction flag        | 方向标志     | 控制串操作指令用的标志：DF=0，串操作过程中地址会不断增值；DF=1，串操作过程中，地址会不断减值
    | IF   | Interrupt enable flag | 中断允许标志 | 控制可屏蔽中断用的标志：IF=0，CPU不能相应可屏蔽中断的中断请求；IF=1，CPU可接受可屏蔽中断的中断请求
    | TF   | Trap flag             | 跟踪标志     | TF=1，CPU按跟踪方式，执行指令
```

## **总线周期（机器周期）**

```markdown
CPU通过总线与存储器或IO接口进行一次数据传输所需的时间
    | T1 | CPU往多路复用总线上发出地址信息，以指出寻址的存储单元或外设端口的地址
    | T2 | CPU从总线上撤销地址，使总线的低十六位为高阻态，为数据传输准备
    | T3 | 总线低十六位上出现由CPU写出的数据或者CPU从存储器或端口读入的数据
    | Tw | 一个或者多个，等待状态，等待外设或存储器的READY信号
    | T4 | 总线周期结束
空闲周期Ti，在一个总线周期结束后，若不执行下一个总线周期，则总线周期处于空闲状态
```



## **引脚信号与工作模式**

```markdown
| 最小工作模式 | 一个8086,总线控制信号都是8086发出
| 最大工作模式 | 多个处理器，主处理器：8086，协处理器：8087，8089等
```
### 引脚和信号
```markdown
引脚总数：20，双列直插封装

A,D复用——AD0..AD15

数据线——16位

    可用高八位传送一个字节
    可用低八位传送一个字节
    也可以用16位数据线传送一个字
    通过/BHE（BUS HIGH ENABLE）信号区分

RESET系统复位信号

READY

/RD：读

/WR：写

M//IO：区分CPU与内存之间传输数据还是CPU与IO接口传送数据

A/S：高四位地址和状态线复用

VCC:+5V

GND：地

AD[0..15]

    AD0信号可以作为低八位数据的选通信号
    CPU的传输特性决定了只要是和偶地址单元或偶地址端口交换数据，那么，CPU必定通过总线低八位传输数据

A19/S6A16/S3（输出）

    地址/状态复用引脚
    S6=0：8086当前与总线相连
    S5=1：允许可屏蔽中断请求
    S4与S3：指出当前正在使用哪个段寄存器

/BHE/S7：高八位数据允许总线/状态复用引脚（输出）

NMI:非屏蔽中断引脚（输入）

INTR:可屏蔽中断请求信号（输入）

    可屏蔽中断请求信号位高电平有效
    CPU在执行每条指令的最后一个时钟周期会对INTR信号进行采样，如果CPU的中断允许标志位（IF）为1，并且又接收到INTR信号，那么，CPU就会在结束当前指令后，响应中断请求，执行一个中断处理子程序。

/RD: 读信号（输出）

    指出将要执行对内存或IO端口的读操作
    与M/IO引脚信号配合，决定读取哪个设备

CLK：时钟（输入）

    8086要求：1/3周期为高电平（33%占空比）

RESET:复位信号（输入）

    至少维持四个时钟周期的高电平才有效

    复位执行的操作是

        CS：设置为FFFFH
        其他：清零

READY：准备好，输入

/TEST:输入

MN//MX:最小和最大模式控制信号，（输入）
```

### 最小工作模式

```markdown
/INTA:中断响应信号，输出

对外设的中断请求做出回应

ALE:地址锁存信号，输出

在任何一个总线周期的T1状态，ALE输出有效电平，以表示当前在地址/数据复用总线上输出的是地址信息，地址锁存器将ALE作为锁存信号，对地址进行锁存。

/DEN：数据允许信号，输出

表示CPU当前准备发送/接收一个数据

DT//R：数据收发信号，输出

M//IO

/WR：写，输出

HOLD:hold          request，总线保持请求信号

HLDA:hold          acknowledge 总线保持响应信号

```

### 最小工作模式下的典型配置

``` mark


锁存芯片——8282或者74ls373
数据总线驱动芯片——8286
```



## **8086的操作和时序**

### 复位

``` markdown
RESET：CPU将CS设置为初值为0FFFFH，其他内部寄存器设置为0
CS被初始化为FFFFH，IP被初始化为0000F，那么复位之后，8086从FFF0H开始执行程序
```

### 总线操作
``` markdown
总线读操作和总线写操作
```
### 中断操作和中断系统

```markdown

8086可以处理256种不同的中断，中断类型号（0255）
```

#### 硬件中断——外部中断
```markdown
非屏蔽中断

    通过CPU的NMI引脚进入，不受中断允许标志IF的屏蔽
    整个系统种只能有一个非屏蔽中断

可屏蔽中断

    通过CPU的INTR引脚进入的，当IF=1时，可屏蔽中断才可以进入
```

#### 软件中断
```markdown
CPU根据某条指令或者软件对标志寄存器中某个标志的设置而产生的
```
#### 中断向量和中断向量表
```markdown

中断系统以位于内存0段的03FFH（01023D）区域中的中断向量表为基础，中断向量表中最多可以容纳256个中断向量

中断向量就是中断处理子程序的入口地址，每一个中断类型对应一个中断向量

一个中断向量占4个存储单元

    前(低位)
    
    | IPL |
    | IPH |
    | CSL |
    | CSH |
    
    后（高位）

256个中断的前5个（04号）中断是专用中断

431号中断为保留的中断

其余中断：用户自定义

```

### 8086的存储器编址和IO编址

#### 存储器编址

```markdown
20根地址线=1MB（2^20）的存储地址空间：（00000-FFFFFH）

寄存器不能直接对1MB的内存空间进行寻址，引入分段的概念

一个段最长64KB（2^16）

各段的地址分别由CS,DS,SS,ES给出，寄存器为16位

存储单元的物理地址：（5位）

段地址左移四位(从16位变成20位)再加16位的偏移量

偏移量又称有效地址：可以放在IP,SP,BP,SI,DI,BX中

8086运行过程中，物理地址的形成因操作而异

    | 取指令                       | CS+IP
    | 堆栈操作                     | SS+SP或者SS+BP
    | 往内存写数据或者从内存读数据   | DS+SI或DS+DI或DS+BX

存储器的操作数可以是一个字节，也可以是一个字

如果是字操作数，低位字节放在较低的地址单元，高位字节放在较高的地址单元
字的地址以低位地址来表示
```

#### 存储器编址的注意事项

```markdown
根据一个物理地址可以反推出多个段地址和偏移量的组合

CS,DS,SS,ES的空间大小为64KB.但是在实际应用中，这些段之间可以有相互覆盖的部分

存储器中有的区域的功能是固定的

    中断向量表:00000-003FFH
    单色显示器的显示缓冲区
    彩色显示器的显示缓冲区
    无条件转移指令
```
#### 奇地址和偶地址

### 8086的IO编址

``` markdown
8086允许有65536（64K）个8为的IO端口

两种编址方式
统一编址

    可以用访问存储器的指令来实现对IO端口的读写，不需要设置专用的IO指令

独立编址

    使用指令系统中的专用的IO指令
```

# 第三章 指令系统

## 寻址方式

寻址就是寻找操作数得来源

### 立即数寻址

```markdown
所调用得操作数就在指令中直接给出
一般用与对寄存器赋值
```

### 寄存器寻址

```

AX BX CX DX SI DI SP BP
对段寄存器不能直接赋值>
MOV AX,0FFFFH 
MOV DS, AX

```

### IO端口寻址


#### IO直接寻址
``` markdown
    IO端口的地址直接在指令中给出
    寻址范围：0-255（00-FFH）
````
#### IO间接寻址
``` markdown
    先把DX寄存器中设置好IO端口的地址，IO指令用DX用寄存器间接寻址
    寻址范围：0-655536（0-FFFFH）
```

### 存储器寻址

```markdown
存储器单元的地址由段基地址+偏移量组成
偏移量就是有效地址EA

有效地址EA = 基址 + 变址 * 比例因子 + 位移量
```



#### 1直接寻址

    存储单元的有效地址由指令直接给出
    MOV        AX,[1070H] ；将**段的1070H（4位）和1071H（4位）两单元的内容取到AX（16位）中
    MOV        AX,ES:[1000H]  ;(带超越前缀)

#### 2寄存器间接寻址

```markdown
存储单元的有效地址由寄存器指出
MOV AX,[BX]
MOV CX,ES:[BX]

默认
SS:BP


DS:SI
DS:DI
DS:BX
```

#### 3寄存器相对寻址

    带位移量的寄存器相对寻址
    MOV AX,[BX+100H]
    寄存器的相对寻址常用做表格处理：将表格的首地址作为位移量，通过修改寄存器的内容指向表格的某一项

#### 4基址+变址的寻址

    基址寄存器BX,BP
    变址寄存器SI,DI
    段地址寄存器为DS时基址寄存器用BX
    段地址寄存器位SS时基址寄存器用BP
    
    当基址寄存器为BX时，段寄存器使用DS，当基址寄存器为BP时，段寄存器用SS。
    
    MOV AX,[BX+SI]
    MOV AX,[BX+DI]
    MOV AX,[BP+SI]
    MOV AX,[BP+DI]
    等价写法：MOV AX,[BX+SI]=======MOV AX,[BX][SI]

#### 5相对的基址+变址寻址

	带有位移量的基址+变址寻址
	MOV AX,[BX+SI+0050H]

#### 6相对的带比例因子的变址寻址（8086没有此功能）

	MOV BX,[SI*4+7]

#### 7基址+比例因子的变址寻址（8086没有此功能）

#### 8相对的基址+比例因子的寻址（8086没有此功能）


## 指令系统

### 传送指令

```markdown
CPU的内存寄存器之间，CPU和存储器之间，CPU和IO端口之间的数据交换


MOV：两操作数的位数相同

    | MOV AL,BL               | 8位的数据从BL送到AL 
    | MOV ES,DX               | 16位的数据从DX从到段寄存器ES中
    | MOV AX,[BX]             | 寄存器寻址方式：间接寻址！BX寄存器中存储的是某个存储单元的偏移地址(eg:1070H)，假设地址为1070H的存储单元中的内容是12H，假设地址为1071H的存储单元中的内容是34H，[BX]的意思时是，取出1070H和1071H这两个存储单元中所存储的内容，也就是1234H，然后MOV，AX,[BX]的意思也就是把取出来的值赋给AX，因此AX中存放的值就是1234H
    | MOV [DI],AX             | 假如AX中的值是1234H，I的值是1070H，那么意思就是，把1234H放到两个偏移地址分别是1070H和1071H的内存单元中，偏移地址为1070H的内存单元中的值是34，偏移地址为1071H的内存单元中的值是12
    | MOV DI,[BX]             |
    | MOV CX,[1000H]          | 
    | MOV WORD PTR [SI],1234H |
    | MOV DX,5040H            | 立即数送到DX

    MOVZX,MOVSX:两操作数的位数不相同

注意

    CS,IP寄存器不能作为目的操作数
    SI,DI来间接寻址时，默认的段寄存器为DS
    BP,SP来间接寻址时，默认的段寄存器为SS

```


### 堆栈指令

```markdown
PUSH：把一个2字节或者4字节的数据推入堆栈

POP:

    | PUSH BX                | 将BX的内容推入堆栈，堆栈指针减2
    | PUSH [BX+DI]           | 把BX+DI和BX+DI+1所指的两内存单元的值压入堆栈
    | PUSH 0870H             | 把立即数压栈
    | PUSH DWORD PTR [BX+SI] | 双字压栈
    | POP BX                 | 栈顶两单元弹出送给BX，栈顶地址+2

```
### 交换指令

```markdown
XCHG：字节，字，双字的交换

实现通用寄存器之间，通用寄存器和存储单元之间，不能在两存储单元之间

    | XCHG AL,BL     |
    | XCHG BX,CX     |
    | XCHG [2530],CX |
```
### 输入输出指令

```markdown
在主机和外部设备之间传送信息时，用输入输出指令

寻址方式

    | 直接的IO指令  | 在指令中直接提供了IO端口号码(寻址范围0255)
    | IN AL,50H    | 把端口50H的内容读入AL
    | IN AX,70H    | 把端口70H的内容读入AL，把端口71H的内容读入AH
    | OUT 80H,AX   | 把AL的内容输出到端口80H，把AH的内容输出到端口81H
    | 间接的IO指令  | 用寄存器DX设置端口号（寻址范围065536）
    | IN AL,DX     | （DX式唯一的，其他的都不可以）
    | IN AX,DX     |
    | OUT DX,AL    |
    | OUT DX,AX    |

```
### 换码指令

```markdown
XLAT:将累加器中的一个值变换成内存表格中的某一个值，一般用来实现编码制的转换
```

### 地址传送指令

```markdown
LEA:取有效地址：将存储器的有效地址送到一个寄存器，常用来使一个寄存器作为地址指针

    | LEA AX,[3820H]          | AX=3820H
    | LEA BX,[BP+SI]          | BX=BP+SI
    | LEA BX,[BP+SI+10H]      | BX=BP+SI+10H
    | LDS DI,[2530H]          | 把2530H，2531H的16位偏移量送到DI，把2532H，2533H的16位段码送到DS

```

### 标志传送指令

```markdown
| LAHF | 将标志寄存器中的低八位传送到AH中
| SAHF | 将AH中的内容送到标志寄存器的低八位
```

### 算数运算指令

```markdown
加法

    | ADD  | 不带进位ADD CX,1000H
    | ADC  | 带进位
    | INC  | a++ INC不会影响CF，即使用INC不会产生进位

减法

    | SUB  | 不考虑借位
    | SBB  | 考虑借位
    | DEC  | a--
    | NEG  | 求补
    | CMP  | 比较指令：执行两个数相减但不送回相减的结果，只影响结果的标志位

乘法（和AX或AL进行运算，隐含寻址）

    | MUL  | 无符号数的乘法 |
    | IMUL | 有符号数的乘法 |

除法（和AX或AL进行运算，隐含寻址）

    | DIV  | 无符号数的除法 |
    | IDIV | 有符号数的除法 |

类型转换

    | CBW  | 字节转换成字 |
    | CWD  | 字转换成双字 |

BCD码
	BCD码加法十进制调整指令
        AAA:用与两个非组合的BCD码相加进行调整，产生有个非组合的BCD码
        DAA:用与两个组合的BCD码相加结果进行调整，产生一个组合的BCD码
        
        MOV AL,37H
        MOV BL,35H
        ADD AL,BL ;两个16进制数相加，AL此时为37H+35H=6C
        DAA ;DAA调整，这时AL为72H。
        
        组合BCD码是通常的8421码，它用4个二进制位表示一个十进制位，一个字节可以表示两个十进制位，即00~99。
        MOV AL，68H ；AL=68H，表示压缩BCD码68
        MOV BL，28H ；BL=28H；表示压缩BCD码28
        ADD AL，BL ；二进制加法：AL=68H+28H=90H
        DAA ； 十进制调整：AL=96H

        非组合BCD码用8个二进制位表示一个十进制位，实际上只是用低4个二进制位表示一个十进制位0~9，高4位任意，但通常默认为0。ASCII码中0~9的编码是30H~39H，所以0~9的ASCII码（高4位变为0）就可以认为是非压缩BCD码。
        MOV AX，0608H ；AX=0608H，表示非压缩BCD码68
        MOV BL，09H ；BL=09H，表示非压缩BCD码9
        ADD AL，BL ；二进制加法：AL=08H+09=11H
        AAA ；十进制调整：AX=0707H
    ------------------------------------------------------------------------
	减法
	AAS  非组合
	
	DAS  组合
	------------------------------------------------------------------------
	AAM 乘法
	
	AAD  除法
	
	
```



### 逻辑运算和移位

```markdown
逻辑运算

    | AND  | 与 AND AX,1000H，结果放到AX
    | OR   | 或 OR AX,1000H，结果放到AX
    | NOT  | 非 NOT AX，结果放到AX，非运算的操作数不能是立即数
    | XOR  | 异或 XOR AX，1000H，结果放到AX
    | TEST | 测试：TEST AL,01H，进行与计算，但是不送回结果，仅改变标志位


移位
    移动一位时，由指令直接给出；移动两位及以上，则移动次数由CL指定
非循环移位指令

    | SAL  | 算数左移 |
    | SHL  | 逻辑左移 |
    | SAR  | 算数右移 |
    | SHR  | 算数右移 |


循环移位指令

    | ROL  | 不带进位的循环左移 |
    | ROR  | 不带进位的循环右移 |
    | RCL  | 带进位的循环左移   |
    | RCR  | 带进位的循环右移   |
```

### 串操作

```markdown

    | 源串一般放在数据段，偏移地址由SI指定 目标串一般放在附加段，偏移地址由DI指定
    | 指令自动修改地址指针，修改方向由DF指定
    | 数据块长度由CX指定
    | CLD与STD是用来操作方向标志位DF（Direction Flag）。CLD使DF复位，即DF=0，STD使DF置位，即DF=1.用于串操作指令中。

重复前缀指令

    | REP   | 无条件重复 |
    | REPE  | 相等重复   |
    | REPZ  | 为零重复   |
    | REPNE | 不相等重复 |
    | REPNZ | 不为零重复 |

    | 字符串传送指令：MOVS
    | 字符串比较指令： COMPS
    | 字符串检索指令：SCAS
    | 取字符串：LODS
    | 存字符串：STOS

IO串操作
```

### 调用，转移，循环，中断

```markdown
转移和调用
    段内直接转移方式
    段内间接转移方式
    段间直接转移方式
    段间间接寻址方式
子程序调用和返回

    CALL
        | CALL 1000H         | 段内直接调用 |
        | CALL AX            | 段内间接调用 |
        | CALL 2500H:3600H   | 段间直接调用 |
        | CALL DWORD PTR[DI] | 段间间接调用 |
    RET

无条件转移和条件转移

    | 无条件转移指令 ： JMP
    | 条件转移指令：
    				JE/JZ  	结果为0则转移
    				JNE/JNZ	结果不为0
    				JG/JNLE 大于（有符号数）
    				JNG/JLE	不大于（有符号数）
    				JL/JNGE	小于（有符号数）
    				JNL/JGE	不小于（有符号数）
    				JB/JNAE 低于（无符号数）
    				JNB/JAE	不低于（无符号数）
    				JA/JNBE	高于（无符号数）
    				JNA/JBE	不高于（无符号数）

循环

    | LOOP   | 
      loop指令的格式是：loop标号，cpu执行loop指令的时候，要进行两步操作
             1：（cx）=（cx）-1   
            2：判断cx中的值，不为零则转至标号处执行，如果为零，则向下执行
    | LOOPZ  |
    | LOOPNZ |

中断

    | INT n      | 执行中断类型n的中断服务程序 |
    | INT0       | 执行溢出中断的中断服务程序  |
    | IRET/IRETD | 从中断服务程序返回调用程序  |

中断指令的执行过程
    将FLAGS压入堆栈；
    将INT指令的下一条指令的CS,IP压栈
    由n*4得到存放中断向量表的地址
    将中断向量（中断服务程序入口地址）送CS和IP寄存器
    转入中断服务程序
    
    IRET 是中断服务子程序的返回指令。
	用于从中断返回， 等价于
	POP CS
	POP IP
	POPF（标志传送指令（标志位出栈指令） POPF）
```

### 标志操作和处理器控制

```markdown
标志操作
暂停指令
交权，等待
总线封锁
```

### 汇编


#### 标记
```markdown
标识符
保留字
分界符
常数
```
#### 表达式
```markdown
操作数

运算符

    算数运算符：+*/和MOD

    逻辑运算符：AND OR NOT XOR

    关系运算符：EQ NE LT GT LE GE

分析运算符

    OFFSET：取存储单元地址的偏移量
    SGE:取存储单元地址的断码
    
    MOV SI,OFFSET BUFFER
    MOV DX,SEG BUFFER
    
    LEA AX,BUFFER

综合运算符

    PTR:用来对存储单元规定类型，通常和后面讲述的伪指令BYTE,WORD,DWORD等连用
    
	MOV BYTE PTR[1000],0
	MOV WORD PTR[1000],0
	MOV DWORD PTR[1000],0
	
	
```
#### 语句

```markdown
- 指令性语句 标志性语句
- 一条指令性语句实际上就是一条指令
- 指示性语句也叫伪指令
- 每条指令性语句在汇编过程中都会产生对应的目标代码
- 指示性语句为汇编程序提供某些信息，让汇编程序在汇编过程中执行某些特定的功能
```



#### 伪指令

```markdown
标号赋值伪指令
	EQU
	MAXNUM EQU 200 

定义存储单元的伪指令：

    | DB   | 字节     | AA DB 0AH
    | DW   | 字       | BB DW 10 DUP(?) 
    | DD   | 双字     |
    | DQ   | 四字     |
    | DT   | 10个字节 |

定义存储单元类型的伪指令：必须与PTR配合使用

    | BYTE  | BYTE PTR  |
    | WORD  | WORD PTR  |
    | DWORD | DWORD PTR |

段定义伪指令

    | SEGMENT |
    | ENDS    |
    | ASSUME  | 告诉汇编程序，哪个段为数据段，哪个段为堆栈段，哪个段为代码段
    | ORG     | 用来规定目标程序存放单元的偏移量   ORG  2000H

简约段定义伪指令

定义过程的伪指令

    | PROC | 子程序
    | ENDP | 
    | NEAR | 段内调用 
    | FAR  | 段间调用

源程序结束伪指令

    | END  | 源程序的结束标志 |
```





# IO

# Ⅰ、接口综述

存储器可以直接挂在到系统总线上，外设不能直接挂在系统总线上

## 接口的基本功能
``` markdown
数据的缓冲与暂存
信号电平与类型的转换
增加信号的驱动能力
对外设进行监测、控制与管理、中断
```

## CPU与IO设备之间的信号

### ①数据信息
``` markdown
数字量
模拟量
开关量
```
### ②状态信息
``` markdown
外设->CPU
    - BUSY
    - READY
```
### ③控制信息
``` markdown
CPU->外设：控制外设的工作
```
## 接口的功能
CPU和外设之间的数据传送方式—>解决CPU与外设之间数据传输时速度不匹配问题

### ①**程序方式**
#### 无条件传送方式
``` markdown
如果CPU能够确信一个外设已经准备就绪，那就不必查询外设的状态而直接进行数据传输，这就是无条件传送方式
只适用于简单的外设的操作：开关，数码管
输入需要缓冲，输出需要锁存
```



#### 条件传送方式
``` markdown
又名“查询方式”
用条件传送方式时，CPU通过执行程序不断读取并测试外设的状态，当外设处于READY或空闲状态时，CPU输入输出指令与外设进行数据交换
在查询方式下，CPU不断读取状态字和检测状态字，如状态字表明外设并未准备好，则CPU等待，占用CPU的时间
```

### ②中断方式
``` markdown
由外设中断CPU的工作，CPU暂停执行当前程序，而去执行一个数据输入输出的程序，此程序称为中断处理子程序或中断服务子程序，中断子程序执行完后，CPU又转回来执行原来的程序
外设主动发起中断请求
CPU本身的功能：
    每条指令执行完后，如有中断请求，那么在中断允许标志位为1的情况下，CPU保留下一条指令的地址和当前的标志，转去执行中断服务子程序
多个中断源产生中断，中断优先级问题？
```

### ③DMA（直接存储器存取方式）

# Ⅱ、串行接口和串行通信

数据是一位一位进行传输的

每一位数据占用一个固定的时间长度

## 空间

``` markdown
全双工
半双工
单工
```

## 时间

``` 
异步方式：收发双方不用统一时钟进行定时
两个字符之间的传输间隔是任意的，每一个字符的前后都要用一些数位来作为分隔位
起始位：每个字符开始传送的标志，起始位采用逻辑0电平
数据位：数据位紧跟着起始位传送；由5-8个二进制位阻成，低位先传；
校验位：奇校验，偶校验，不传送校验位
停止位：表示该字符传送结束。停止位采用逻辑电平1，可选择1，1.5或2位
---------------------------------------------------------------------------------------------------------------
同步方式：收发双方采用同一个时钟信号定时
以一个固定长度的字符阻成的数据块为传输单位，每个数据块附加一个或两个同步字符，最后以校验字符结束
```

## 串行通信的传输率

``` markdown
波特率：指的单位时间内传送二进制数据的位数，单位为位/秒（bps）

发送时钟：决定数据位宽度的时钟

接收时钟：用与测定每一位输入数据位宽度的时钟

发送/接收时钟=n*波特率

- n为波特率因子，表征多少个时钟周期传输一个bit
- n=1或16或32或64
- 接收端一般n远大于1
```



# Ⅲ、8251A

## 1.基本性能

可以工作在同步或异步方式
![1](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/1.png)

## 2.基本工作原理

![2](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/2.png)

### 七个模块

``` markdown
接收缓冲器
	从RXD引脚上接收串行数据，并按照相应的格式将串行数据转换成并行数据

接收控制电路
	对接收的数据进行检测，检测起始位，校验位，停止位等

发送缓冲器
	把来自CPU的并行数据加上相应的控制信息，然后转换成串行数据从TXD引脚发送出去

发送控制电路
	控制插入起始位，校验位，停止位，同步字符等

数据总线缓冲器
	把8251和系统总线相连，在CPU执行输入/输出指令时，游数据总线缓冲器发送和接收数据
	控制字，命令字和状态信息也通过数据总线缓冲区传输

读/写控制逻辑电路

    接收写信号 /WR，并将来自数据总线的数据和控制字写入8251A
    接收读信号 /RD，并将数据或状态字从8251A送往数据总线
    - C//D：控制/数据信号；C//D   /WR   /RD三个信号组合起来通知8251A当前读写的是数据，控制字，还是状态字
    - CLK：时钟信号
    - RESET：复位信号

调制/解调控制电路
	实现 8251A与调制/解调器的连接
```

### 8251A的发送和接收

#### 异步方式
``` markdown
接收

    在异步方式准备接收一个字符的时候，RxD就在线上检测低电平（没有检测的时候就是高电平），假如这个时候检测到了低电平，8251A就会以这个低电平作为起始位，并且启动内部定时计数器，当计数器到一半数位传输时间（比如初始设置时间脉冲为波特率的16倍），则定时器到第八个脉冲的时候，又重新对RxD进行取样，如果仍为低电平就确定是一个有效的起始位，（如果这个时候为高电平了，8251A会认为刚刚低电平是一个干扰信号，这个过程就重头开始了），8251就开始进行常规取样并进行字符装配（就是每隔一段时间对RxD进行采样）数据进入移位寄存器后（并进行去掉奇偶校验位和停止位），变成并行数据，在通过内部总线送到数据输入寄存器，同时发出RxRDY信号到CPU，表示外设的数据已经收到了，是可用的。对于少于八位的，高位自动填零

发送

    当程序把TxEn（允许发送信号）和CTS#（清除请求发送信号，不懂的朋友再仔细看看上文）后就开始发送。在发送的时候，发送器自动添加1个起始位，再按照初始化的格式添加奇偶校验位，停止位。数据及起始位，校验位，停止位总是在发送时钟的TxC下降沿时发出
```
#### 同步方式

``` markdown
接收

    其实和异步也差不多，就是RxD先进行搜索同步字符，找到第一个数据了，送到移位寄存器移位，然后和同步字符的内容进行比较，相等就是找到了，SYNRET=1；开始接收数据块，不相等就重新来（双同步也差不多，就是第一次找到了再来一次，第二次找不到重头开始找第一个字符）,如果是外同步的话，如果SYNDET=1；的时候，直接开始，RxD就不用找起始位了直接开始采样数据块。
    实现同步之后，就利用时钟信号对RxD进行数据采样，送到移位寄存器移位，然后从RxRDY引脚发出一个信号，表示已经收到了一个字符，一旦CPU读完之后，这个RxRDY=0；

发送

    发送也差不多，程序先对TxEN和CTS#初始化了，这个时候就开始发送，程序会先发1/2个同步字符，然后发送数据块，发送数据块的时候，发送器自动按初始化要求添加奇偶校验位（没有就不加）。如果8251正在发送的时候CPU来不及发送数据了（比如说遇到了中断之类的），那么就会重新发1/2个同步字符，等待CPU。满足了同步字符之间没有空隙。
```


## 3.8251A的对外信号



### 8251A和CPU之间的连接信号

![9](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/9.png)

``` markdown

片选信号

	/CS：CS#，片选信号，由M/IO#和地址译码器得到

数据信号

    - D0-D7：D0-D7        数据传输信号
    8251A的8根数据线D7-D0与8086的数据总线相连

读/写控制信号

    /RD：RD# 读信号，CPU从8251A中读信息
    /WD：WR# 写信号，CPU写入8251A

    8251只有两个端口地址，数据端口是偶地址（输入输出是一个端口），控制信息是奇地址，在8086中是用A1来区分奇偶地址的，如果A1是0，就是偶地址，A1为1就是奇地址，这刚好和C/D#对应了，所以A1脚通常连接C/D#

    | C//D    | /RD     | /WD     | 操作                   |
    |—————————|—————————|—————————|————————————————————————|
    | 0       | 0       | 1       | CPU从8251A输入数据      |
    | 0       | 1       | 0       | CPU往8251A输出数据      |
    | 1       | 0       | 1       | CPU读取8251A的状态      |
    | 1       | 1       | 0       | CPU往8251A写入控制命令  |

收发联络信号

    - TXRDY：发送准备好信号，用来通知CPU，8251A已经准备好发送一个字符

    - TxRDY：发送器准备好，输出，high，表示发送器已经准备好了，这表示发送数据缓冲器空的（没空怎么发啊），CPU可以向8251A发送数据。如果用中断形式的话，这个TxRDY也可以做中断请求信号，如果是查询方式就不断查询它就完事了

    - TxE 发送空信号，输出，high，表示并串转化器为空（数据要经过并串转化器把并行数据转化成串行数据才能发送）。如果8251获得一个数据，TxE就为低。在同步方式下不允许字符串有间隔，但如果CPU来不及给8251A发送数据，则TxE就为1，插入同步字符

    - RxRDY，表示接受器准备好了，可以接受数据了，如果从外设接收到一个数据，等待CPU处理，当然也可以用中断了，把这个当成中断请求信号，程序查询就查他就完事了

    - SYNDET：同步检测信号（只用于同步方式）
    		同步检测/断电检测信号，高有效，输出/输入 同步方式时表示同步检测，如果为内同步，作为输出，输出为1，表示找到同步字了；在外同步的时候，作为输入，变高后，在RxC#（接收器时钟）的下一个下降沿装配字符，在异步方式下，作为空白检测信号，输出，如果接收到全0的字符，输出高电平
```

### 8251A与外设的连接信号

![3](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/3.png)

``` markdwon
数据信号
    - TXD
    发送数据信号TXD用来输出数据，CPU送往8251A的并行数据转换为串行数据后，通过TXD送往外设
    - RXD
    接收数据信号RXD用来接收外设送来的串行数据，数据进入8251A后，转换为并行方式

和外设的联络信号
    - DTR#  数据终端准备好了，由8251A发给外设，表示CPU准备就绪
    - DER#  数据设备请求好了，由外设发给8251A，表示外设已经准备就绪
    - RTS#  请求发送信号，由8251A发送给外设，表示CPU已经准备好发送
    - CTS#  清除请求发送信号，由外设发送8251A，表示可以往外设发送数据
    - CLK          8251A的内部时序时钟，同步要求是波特率的30倍，异步的话要求波特率的4.5倍
    - TxC，发送时钟，输入，控制字符的发送速度，同步是等于字符传送的波特率，异步方式是初始化定义的
    - RxC，和TxC差不多，是控制接受端的接受速度

时钟、电源、地
    - CLK：用来产生8251A器间的内部时序
    - TXC:发送器时钟输入，用来控制发送字符的速度
    - RXC:接收器时钟输入，用来控制接收字符的速度
    - VCC
    - GND
```
## 4.编程

![4](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/4.png)

### 8251A的初始化

8251A有一个奇一个偶两个端口地址；

``` markdown
偶地址端口对应数据输入寄存器和数据输出寄存器；
奇地址端口对应状态寄存器，模式寄存器，控制寄存器，同步字符寄存器
```

#### 用偶地址端口时(A1=0)
``` markdown
写入：数据输入寄存器
读出：数据输出寄存器
```

#### 用奇地址端口时（A1=1)(8251A初始化的约定)
``` markdown
第一种描述方法（来自课本）
    芯片复位以后，第一次用奇地址端口写入的值作为模式字送入模式寄存器
    如果模式字中规定了8251A工作在同步模式，那么，CPU接着往奇地址端口输出的就是同步字符，同步字符被写入同步字符寄存器。如此前规定同步字符为两个，则会按先后次序分别写入第一个同步字符寄存器和第二个同步字符寄存器
    此后，只要不是复位命令，不管是同步模式，还是异步模式，由CPU往奇地址端口写入的值都将作为控制字送到控制寄存器，而往偶地址端口写入的值将作为数据，送到数据发送缓冲器

第二种描述方法（来自网络）
    芯片复位之后，第一次用奇地址写控制字，在控制字中规定是同步还是异步；
    如果是同步方式，CPU会接着发1或者2个字节就是同步字符，写入同步字符寄存器，然后再把控制命令字写入奇端口；
    如果是异步方式，CPU往奇端口输出的一个字就是命令控制字；
    在相关命令设置好了之后，只要不复位，用奇端口写控制字，偶端口写的是数据，送到数据输出缓冲器中
```
####  地址说明
``` markdown
- 关于8位接口芯片和16位数据总线的连接问题
    - 8086CPU有一个必须遵守的约定，即低八位数据线总是与偶地址存储单元或端口关联；
    - 而高八位数据线总是与奇地址存储单元或端口关联；
    - 为了满足这一个要求，连接时在硬件上将总线的A1与8251A的C//D引脚相连接，而在软件设计的时候，用连续的偶地址代替端口的奇偶地址，就解决了8位接口芯片与16位数据总线的连接
```
#### 初始化的概述

``` markdown
- 模式字决定了8251A将工作在同步模式还是异步模式，如果工作在同步模式，还会指出同步字符的个数是一个还是两个；同步字符被写入同步字符寄存器
- 如果是异步模式，则在设置完模式字后，接着便要设置控制字
控制字的主要含义相同，控制字就是各种控制命令，包括复位命令
- CPU向8251A发送控制字之后，8251A首先判断控制字是否为复位命令：如果是复位命令，则返回重新接收模式字；如果不是复位命令，则8251A开始进行数据传输。
```
### 模式寄存器的格式

模式字**8位**

#### 异步模式

需要考虑的量：停止位/校验位/校验允许位/数据位的数目/波特率因子

![5](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/5.png)
``` markdown
（从高到低）
前两位是停止位的数目，00非法，01是1位，10是1.5位，11是2位停止位
第三位是EP（奇偶校验类型），0为奇校验，1为偶校验
第四位是有无校验，0是无，1是有
第五第六位是数据的大小，00是5位，01是6位，10是7位，11是8位
最后两位是决定波特率因子（不能是00，00就表示同步通信了），01表示波特率因子为1，10表示波特率因子为16，11表示波特率因子为64
举个例子，异步通信，1个停止位，无校验，8个数据位（刚好最近在做单片机的串口通信，这就是8N1格式）波特率因子为16，则应该向奇端口（假设还是FFF2H吧）写入01001110B，HEX格式为4EH、
- MOV DX,       FFFEH（端口地址）
- MOV AL, 4EH（模式字）
- OUT DX, AL


波特率
同步模式下，发送和接收的波特率分别和/TxC引脚，/RxC引脚上的输入时钟的频率相同
异步模式下，要用模式寄存器中的最低2位来确定波特率因子，
此时满足: /TxC引脚，/RxC引脚上的输入时钟的频率=波特率因子*波特率
```
#### 同步模式

需要考虑的量:同步字符的数目/同步方式/奇偶校验/奇偶校验允许位/数据位的数目/同步模式
![8](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/8.png)

``` markdown
（从高到低）
第一位是同步字符的位数，0是2个同步字符，1是1个同步字符
第二位决定是内同步还是外同步，0是内同步，1是外同步
第三位是奇偶校验位，0是奇校验，1是偶校验
第四位是有没有校验，0是没有校验，1是有校验
第五第六位是决定数据块的位数，00是5位，01是6位，10是7位，11是8位
最后两位必定是00
举个例子，比如说现在要求发送的是同步方式，1个同步字符外同步，偶校验，数据位是8位，那么初始化命令字就应该向奇端口（假如为FFF2H）写01111100B，换成16进制就是79H
汇编初始化就应该是
- MOV DX FFF2H
- MOV AL 79H
- OUT DX AL
````
### 控制寄存器的格式

![6](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/6.png)
``` markdown
从高到低
第七位：检索同步字符，只用在内同步模式，为1时，8251A会对同步字符进行检索
第六位：使8251A复位，从而重新进入初始化流程
第五位：用来设置发送请求，此位置为1会使得/RTS引脚输出为低电平
第四位：1将清楚状态寄存器中所有的出错指示位
第三位：为1使得引脚TxD变为低电平，于是输出一个空白字符
第二位：接收允许信号，在CPU从8251A接收数据前，先使此位为1
第一位：DTR
第零位：发送允许信号，只有将此位是1时，才能使数据从8251A接口往外设传输
```
### 状态寄存器的格式

![7](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/7.png)
``` markdown
当需要检测8251A的工作状态时，需要用到状态字。
状态字存放在状态寄存器中。
```

## 应用举例

### 异步模式下的初始化程序举例

设8251A工作在**异步模式**，波特率系数(因子)为16，7个数据位/字符，偶校验，2个停止位，发送、接收允许，设端口地址为0042H。完成初始化程序。
``` assembly
;- 模式字：1111010B->FAH
;- 控制字：00110111B->37H (?)
;- 端口地址:对于CPU来说是偶地址，对于接口是奇地址

;- 初始化：
MOV AL,0FAH;送模式字
OUT 42H,AL ;异步方式，7位字符，偶校验,2个停止位  
MOV AL,37H;设置控制字，使发送、接收允许，清出错标志，使 /RTS和/DTR有效 
OUT 42H,AL ;送控制字
```


### 同步模式下初始化程序举例 

设端口地址为42H，采用内同步方式，2个同步字符（设同步字符为16H），偶校验，7位数据位/字符 

``` assembly
;- 模式字00111000B 即38H
;- 控制字为：10010111B 即97H（？）。它使8251A对同步字符进行检索；同时使状态寄存器中的3个出错标志复位；此外，使8251A的发送器启动，接收器也启动；控制字还通知8251A，CPU当前已经准备好进行数据传输。 

;具体程序段如下：  
MOV AL，38H  ;设置模式字，同步模式，  用2个同步字符，
OUT 42H，AL   ; 7个数据位，偶校验
MOV AL，16H  
OUT 42H，AL   ;送同步字符16H
OUT 42H，AL    ;同步字符有两个一样的，因此送两次
MOV AL， 97H   ;设置控制字，使发送器和接收器启动
OUT 42H，AL
```
### 利用状态字进行编程的举例 

先对8251A进行初始化，然后对状态字进行测试，以便输入字符。本程序段用来输入80个字符。

分析：8251A的控制和状态端口地址为42H，数据输入和输出端口地址为40H。字符输入后，放在BUFFER标号所指的内存缓冲区中。
``` assembly
;具体的程序段如下：
    MOV AL,0FAH 
    OUT 42H,AL
    MOV AL,35H
    OUT 42H,AL
    MOV DI,0
    MOV CX,80
B：
    IN AL,42H
    TEST AL,02H
    JZ B  
    IN AL,40H
    MOV BX,OFFSET BUFFER
    MOV [BX+DI],AL
    INC DI
    IN AL,42H
    TEST AL,38H 
    JNZ E
    LOOP B
    JMP EXIT
E： 
    CALL ERR-OUT      
    EXIT:... ...
```


# Ⅳ、并行接口和并行芯片


- 并行通信就是把一个字符的各位用几条线同时进行传输；

-  ![10](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/10.png)

``` markdown
- 控制寄存器

	- - 用来接收CPU的控制命令

- 状态寄存器

	- - 提供各种状态位供CPU查询

- 输入缓冲寄存器

- 输出缓冲寄存器

```


# Ⅴ、8255A

可编程并行通信接口8255A

## 1.8255A的内部结构

![11](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/11.png)

### ①数据端口A,B,C

``` markdown
- Port A
    端口A具有一个8位数据输入锁存器和一个数据输出锁存器/缓冲器；
    用端口A做输入口或输出口时，数据均受到锁存

- Port B
    端口B具有一个8位数据输入缓冲器和一个数据输出锁存器/缓冲器；

- Port C
    端口C具有一个8位数据输入缓冲器和一个数据输出锁存器/缓冲器，一般作为控制或状态信息端口
    当端口C作为输入口时，对数据不锁存
    当端口C作为输出口时，对数据进行锁存

使用中，A，B口为两个独立的数据输入输出端口，C口配合A口和B口的工作
C口常常通过控制命令被分成2个四位的端口，分别用来为端口A和B提供控制信号和状态信号
```

### ②A组控制和B组控制

``` markdown
控制端口A与端口C的高4位（PC7-PC4）
控制端口B与端口C的低4位（PC3-PC0）
```

### ③读/写控制逻辑电路

```markdown
功能：管理数据传输过程。

CS#-片选信号

A0、A1-端口选择信号

RD#-读信号

WR#-写信号

RESET-复位信号

读写控制逻辑：接收/CS信号以及来自地址总线的选择端口信号（A2 A1），还接收控制总线的信号/WR,/RD,REST，并将其组合成A和B组的控制信号
```


### ④数据总线缓冲器

```markdown
双向三态的8位数据缓冲器，8255A正是通过它与系统数据总线相连
```

## 2.芯片引脚信号

### 和外设相连的信号

```markdown
PA0－PA7：A口的8条输入输出信号线。
PB0－PB7：B口的8条输入输出信号线。
PC0－PC7：C口的8条输入输出信号线。
```

### 和CPU相连的信号


```markdown
D0－D7：双向数据信号线。和系统总线相连
/RD：读信号线。
/WR：写信号线。
/CS：片选信号线。当片选信号有效时，读信号和写信号才对8255A有效
A1、A0：口地址选择信号线。8255A有四个端口地址
00--A端口；01--B端口；10--C端口；11--控制口。
RESET：复位输入信号，复位时内部寄存器都被清除，同时，三个数据端口自动置为输入口
```

![12](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/12.jpg)

### 端口地址举例说明

![13](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/13.png)

## 3.控制字

控制字分为两类：各端口的方式选择控制字和C端口的按位置1/置0控制字

```markdown
控制字的D7位称为标识位
D7=1--->方式选择控制字的标识符
D7=0--->C端口的按位置1/置0控制字的标识符
```

### 方式选择控制字

方式选择控制字的格式

![14](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/14.jpg)

说明

```markdown
8255A的[三种工作方式]
    方式0：基本的输入/输出方式
    方式1：选通的输入/输出方式
    方式2：双向传输方式

端口A可以工作在三种工作方式的任意一种，端口B只能工作在方式0或方式1，端口C则常配合端口A和B的工作，为这两个端口的输入/输出提供控制信号和状态信号
归为同一组的两个端口可以分别工作在输入或输出方式，不要求其工作同输入或输出
```



### 端口C置1/置0控制字

![15](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/15.jpg)

```markdown
○ 8255A的端口C的各位均可用置1/置0控制字单独设置，因此C端口很适合做控制位使用
○ 当8255A收到控制字时，就对最高位即标识位进行检测，D7=1，将此字节作为方式选择控制字写入控制寄存器，D7=0，将此字节作为端口C置1/置0控制字
○ C端口的按位置1/置0控制字注意：
    § C端口的按位置1/置0控制字尽管时对C端口进行操作，但必须写入控制端口，而不是写入C端口
    § D0位决定置1或置0 ，D0=0置0; D0=1置1
    § D3、D2、D1位决定了对C端口中的哪一位操作 
    § D4 5 6无影响
    § D7位必须为0 
```



## 4.工作方式

```
方式0：基本输入输出方式	适用于无条件传送和查询方式的接口电路（传输方式转8086页面）
方式1：选通输入输出方式	适用于查询和中断方式的接口电路
方式2：双向选通传送方式	适用于双向传送数据的外设	适用于查询和中断方式的接口电路
```

### ①方式0

基本的输入/输出方式

特点

```
- PA和PB可通过方式选择控制字规定为输入或者输出端口- PC分为两个四位端口，高四位一个端口，第四位一个端口；这两个四位端口，也可以通过方式选择控制字规定为输入或输出端口端口可作为输入口，也可作为输出口，各端口之间没有规定必然的联系。可以有16种不同的组合，适用于多种不同的场合。 


8255A中方式0对输出进行锁存（和总线相连肯定要锁存的），输入不锁存
8255A中没有时钟输入信号，所有的时序都是由引脚控制信号定时的
当CPU执行IN指令的时候，产生RD#信号，控制8255A从端口读取外设的输入数据，然后从D0-D7中输入到CPU
当CPU执行OUT指令的时候，产生WD#信号，完成CPU从端口向外传输数据
```

时序

输入（CPU从8255A读取数据）时序要求

```
发出读信号前，先发出地址信号，从而使得8255A的片选信号和端口选择信号A1         A0有效，于是启动8255A输入数据要领先于读信号（要求在CPU发出读信号之前，外设已经将数据送到8255A的输入缓冲器中） 
```

输出（将数据有效传输到8255A）时序要求

```
略
```

应用

```
用于连接简单外设。适用于：（1）无条件输入输出方式。（2）查询输入输出方式：A、B口作为8位数据的输入或输出口，C口的高/低4位分别定义为A、B口的控制位和状态  位，作为A（B）的应答信号。应答信号不固定，可自由定义应用实例：作为主机和打印机的接口
```



### ②方式1

选通的输入/输出方式

特点

```
- PA和PB用方式1进行输入/输出，端口C自动提供选通信号和应答信号
- PA和PB端口只有一个工作在方式1，那么PC一个端口中有3位被规定为配合方式1工作的信号，PC的另一个端口可以工作在方式0，PC的其他位以可工作在方式0，即作为输入/输出
- PA和PB都工作在方式1，那么PC中就需要6位用来作为配合方式1工作的信号，剩下的两位可以作为输入和输出




方式1是单方向的输入/输出工作模式

将3个端口分成两组，端口A和B可以两个数据口，分别工作在方式1，而端口C用来配合端口A和B在方式1下进行工作，作为选通信号

注：

A口工作于方式1输入，固定用PC5-PC3作联络信号线；

A口工作在方式1输出的时候，PC7，PC6和PC3作为选通信号

B口工作于方式1输入输出的时候，固定用PC2-PC0作联络信号线。

如果AB都用方式1进行传输，C口剩下的两位可以工作在方式0下
```

时序

输入信号和输入时序

 ![16](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/16.jpg)

```
所用到的控制信号的定义如下：

  ① STB为低电平有效的输入选通信号，由外设提供的输入信号，当它有效时，把输入装置来的数据送入输入锁存器。

  ② IBF为高电平有效的输入缓冲器满信号，通知外设送来的数据已被接收，由STB信号的前沿产生。当CPU用输入指令读走数据后，此信号被清除。 

  ③ INTR为中断请求信号，高电平有效。CPU响应中断请求后在服务程序中读走数据时，由RD信号将其清除。

  ④ INTE为中断允许状态，可事先用位控方式写入。
```

输出信号和输出时序

 ![17](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/17.jpg)

```
当CPU相应了8255的中断后，发出WD#信号，输出数据到锁存器中。输送完了之后，WD有效的时候，打开OBF#为0，缓冲器满，告诉CPU不要写数据到8255A了，（OBF#也是外设的选通信号）同时INTR为0（已经响应了中断）。当外设读完了数据，WD为1，发送响应信号ACK#，ACK#的上升沿也把OBF置为1，缓冲器空，INTR为1，发送下一个中断，可以读下一个数据了
```



应用

```markdown

```



### ③方式2
双向传输方式

特点

```
方式2将方式1的选通输入输出功能组合成一个双向数据端口，可以发送数据和接收数据；只有端口A可以工作于方式2，需要利用端口C的5个信号线，其作用与方式1相同；方式2的数据输入过程与方式1的输入方式一样；方式2的数据输出过程与方式1的输出方式有一点不同：数据输出时8255A不是在OBF#有效时向外设输出数据，而是在外设提供响应信号ACK#时才送出数据

当A端口工作方式2的时候（需要PC3-PC7），B口还可以工作在方式1（需要PC0-PC2）和方式0（PC0-PC2可以在方式0啦）
```

时序

![18](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/18.png)

``` 
如果A口外设输入数据到8255中的时候，STB#有效，外设数据输入到A的PA0-PA7，输完数据后，STB为1，同时IBF为1，触发中断，INTR为1，CPU响应中断，发出IN指令，RD为0，当RD有效的时候，INTR为0（表示已经响应了中断），数据传输到数据总线中，读完后，INFA为0，继续开始读取数据

如果8255发送了一个中断，CPU响应了中断，发出WR#信号，数据从总线中到锁存器中，在WR有效的时候清除INTR（响应了中断）。同时让OBFA为0（PC7），告诉外设要读数据了，外设读完后发出响应信号ACK#，ACK上升沿恢复为1的时候，触发OBFA为1，又触发了中断

注意，由于A口的输入锁存器和输出锁存器是互相独立的，故当CPU向A口输出数据时，外部设备也可同时向A口输入数据。反之亦然。
```
应用

```
磁盘驱动器
```



## 5.应用举例


# Ⅵ、8259A

``` 
中断控制器的功能：
    接收外部的中断请求，进行判断，选中优先级最高的中断请求，送到CPU的INTR端；CPU响应中断进入中断子程序时，负责对外部中断请求管理，可实现中断嵌套。

8259A的工作特点： 

    ① 能管理8级中断，可与其它8个8259A芯片组成主从式中断系统，实现64级中断源控制；

    ② 可编程使用，非常灵活；

    ③ 只需一组5V电源。
```

## 1.外部信号和含义

![19](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/19.png)

```
① D7～D0 数据线：在系统中，他们和数据总线相连

② INT 中断请求信号：和CPU的INTR端相连，向CPU发送中断请求

③ INTA# 中断应答信号：接收来自CPU的中断应答信号，如果CPU接收到中断请求信号，而此时中断允许位标志为1，并且正好一条指令执行完毕，那么在当前总线周期和下一个总线周期中，CPU将在/TNTA引脚上分别分发一个负脉冲作为中断响应信号，在第二个/INTA脉冲结束时，CPU读取8259A送到数据总线上的中断类型号

④ RD# 读出信号：将8259A某个内部寄存器的内容送达数据总线

⑤ WR# 写入信号：使8259A从数据总线上接收数据

⑥ CS# 片选信号

⑦ A0 端口选择信号：8259A有两个端口地址，一个为奇地址，一个为偶地址，奇地址较高，偶地址较低

⑧ IR7～IR0 I/O中断请求信号：与IO设备相连或者说连接从片的INT引脚，接收其中断请求

⑨ CAS2～CAS0 从片选择信号

⑩ SP#/EN# 主片和从片的选择和驱动信号

    /SP//EN：双功能引脚

    （1）输出，低电平有效

        8259A工作在缓冲方式时，该引脚输出低电平控制信号，用来使能系统总线与8259A数据引脚之间的数据缓冲器，使中断向量码能在第二个INTA周期正常从8259A输出。

    （2）输入

        当8259A工作在主从级联方式时，该引脚为输入：

        SP=1，设定8259A为主片；

        SP=0，设定8259A为从片
        
        
```





## 2.编程结构和工作原理

![20](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/20.jpg)

![22](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/22.jpg)

### 组成
```
	控制部分——7个寄存器（八位的寄存器）

    初始化命令字ICW（1-4）
    	功能：决定8259A的工作方式
         通常是在计算机系统启动时在初始程序设置，一旦设定，一般在系统工作过程不再改变。
    操作命令字OCW（1-3）
        功能:在应用程序中设定，动态地控制CPU处理中断的过程
        中断屏蔽寄存器IMR（OCW1）
        保存对中断请求信号IR的屏蔽状态,Di位为1表示IRi中断被屏蔽（禁止）；为0表示允许

	处理部件（8位的寄存器）

    功能：接收和处理从IR0-IR7进入的中断
    - IRR——中断请求寄存器
        保存8个外界中断请求信号IR0～IR7的请求状态
        - Di位为1表示IRi引脚有中断请求；为0表示无请求
        
    - PR——中断优先级裁决器

    - ISR——当前中断服务寄存器
        保存正在被8259A服务着的中断状态
        Di位为1表示IRi中断正在服务中；为0表示没有被服务
```
### 工作原理

![](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/21.jpg)

（1）接收、处理外设中断申请，决定是否向CPU发中断申请信号。
（2）若CPU响应中断，则在CPU中断响应周期送出中断类型号。

```
中断请求寄存器IRR接收外部中断请求，IRR有8位，分别和引脚IR7-IR0相对应;
接收来自某一引脚的中断请求后，IRR寄存器的对应位置便置1，即对此中断请求锁存;
此后，逻辑电平根据中断屏蔽寄存器IMR中对应位决定时候让此请求通过;
决定IRR中的中断申请是否进入优先级裁决器PR。
    IMR对应位为0，允许中断申请进入优先级裁决器，
    IMR对应位为1，不允许进入，中断申请被IMR屏蔽。
```

```
中断优先级裁决器PR把新进入的中断请求和当前正在处理的中断比较，从而决定哪一个优先级更高
当前中断服务寄存器 ISR 记录CPU正在响应的中断。
- ISR中的某位为1，表示CPU正在响应此级中断，即正在执行此中断源的中断子程；
- ISR中的某位为 0，表示CPU没有或已响应完此级中断，即不在执行此中断源的中断子程

如果进入的中断申请比ISR中记录的中断优先级高，则通过8259A的INT引脚 CPU发出中断请求信号；
如果进入的中断申请不比 ISR 中记录的中断优先级高，     同级或低级，则不向 CPU 发中断请求信号。
```

```
如果CPU的中断允许标志位IF为1,那么CPU执行完当前指令后，就可响应中断，这时，CPU从/INTA端往8259A送出两个负脉冲:


第一个负脉冲到达时，8259A完成三个动作
    - 使IRR锁存功能失效。对IR7-IR0线上的中断请求信号就不再接收；直到第二个负脉冲到达时，才使IRR锁存功能有效
    - 使当前中断服务服务器ISR中的相应位置1，以便中断优先级裁决寄存器以后的工作提供判断依据
    - 使IRR寄存器中的相应位清零（之前接收中断请求时设置的1，现在需要清零）


第二个负脉冲到达时，8259A完成两个动作
    - 将中断类型寄存器中的内容ICW2送到数据总线的D7-D0，CPU将此作为中断类型号
    - 如ICW4中的中断自动结束位为1，则将当前中断服务寄存器ISR的相应位清零
```
## 3.工作方式

### 设置优先级的方式

#### 全嵌套方式
```
最常用的方式

8259A的中断优先权顺序固定不变，从高到低依次为IR0、IR1、IR2、……IR7。0级优先级最高
中断请求后，8259A对当前请求中断中优先权最高的中断IRi予以响应，将其中断类型码送上数据总线，对应ISR的Di位置位，直到中断结束（ISR的Di位复位）。
在ISR的Di位置位期间，禁止再发生同级和低级优先权的中断，但允许高级优先权中断的嵌套。
```
#### 特殊全嵌套方式
```
与全嵌套方式基本相同，只有一点不同：当处理某一级中断时，如果有同级的中断请求，也会给予响应。

特殊全嵌套方式一般用在8259A级联系统中。

一方面，CPU对于优先级别较高的主片的中断输入是允许的；
另一方面，CPU对于来自同一从片的优先级别较高（但对于主片来讲，优先级别是相同的）的中断也是允许、能够响应的。
```
#### 优先级自动循环方式
```
适用场合：系统中多个中断源优先级相等。
初始优先级队列规定为：IR0~IR7。从IR0～IR7引入的中断轮流具有最高优先权。当任何一级中断被处理完，它的优先级别就被改变为最低，而最高优先级分配给该中断的下一级中断。
例如：现正为IR3引入的中断服务，若服务完毕，IR3为最低优先级，IR4有最高优先级，优先级顺序为 IR4,IR5,IR6,…IR2,IR3。
优先级自动循环方式——由OCW2决定
```
#### 优先级特殊循环方式
```
与优先级自动循环方式相比，只有一点不同：初始优先级是由编程决定的。
例如：编程确定IR5为最低优先级，则IR6为最高优先级，初始优先级顺序为IR6,IR7,IR0…IR4,IR5。
优先级特殊循环方式——由OCW2决定
```
### 屏蔽中断源的方式

#### 普通屏蔽方式
```
8259A的每个中断请求输入端都可通过对应屏蔽位的设置而被屏蔽

将OCW1（IMR）的Di位置1，则对应的中断IRi被屏蔽，该中断请求不能从8259A送到CPU。
如果OCW1（IMR）的Di位置0，则允许IRi中断产生。
撤销屏蔽：可以再程序中根据需要设置OCW1（IMR）寄存器的值。
```
#### 特殊屏蔽方式
```
将OCW1（IMR）的Di位置1，对应的中断IRi被屏蔽的同时，使ISR的Di位置0；
开放了其他级别较低的中断。

特殊屏蔽是在中断处理程序中使用的，用了这种方式之后，尽管系统正在处理高级中断，但对外界来讲，只有同级中断被屏蔽，而允许其它任何级别的中断请求。
应用场合： 一个中断服务程序的运行过程中，需要动态地改变系统中的中断优先级结构，即：在中断处理的一部分，禁止低级中断嵌套；而在中断处理的另一部分，允许低级中断嵌套
```
### 结束中断处理的方式
```
中断结束是什么：

CPU响应某级中断后，8259A自动将ISR的对应位置1，如果CPU已执行完中断子程，而ISR中的对应位仍为1,8259A的优先级裁决器仍会据ISR的内容做裁决，从而会屏蔽同级或低级的中断申请。在中断响应后，对 ISR中相应位的清0很重要，  它是8259A认为中断结束的标志。
```
#### 中断自动结束方式
```
适用于系统中只有一片8259A且多个中断不会嵌套的情况。
系统进入中断过程，8259A就自动将当前中断服务寄存器中对应位ISn清除。
方法：ICW4中AEOI位为1。
```
#### 中断一般结束方式
```
配合全嵌套优先权方式使用。
当CPU用输出指令往8259A发出一般中断结束命令（EOI）时，8259A就会把当前中断服务寄存器优先权最高的IS位复位。
方法:在程序中，往8259A的偶地址端口输出一个操作命令字OCW2,OCW2的EOD=1,SL=0,R=0z
```
#### 特殊的中断结束方式
```
配合非全嵌套方式使用。
- CPU在程序中向8259A发送一条特殊中断结束命令（SEOI），这个命令中指出了要清除哪个IS位。
方法：OCW2中的EOI=1,SL=1,R=0

8259A级联方式下，一般采用非自动结束方式。CPU应发出两个中断结束命令，一个送主8259A，用来将其主8259A的ISR寄存器相应位清“0”；另一个送从8259A，用来将其从8259A中的ISR寄存器相应位清“0”。
```
### 连接系统总线的方式

#### 缓冲方式
```
8259A的数据线需加总线驱动器予以驱动。
8259A把 SP#/EN#       引脚作为输出端，输出允许信号（低电平），作为总线驱动器的启动信号。

由ICW4设置
```
#### 非缓冲方式
```
8259A直接与数据总线相连。
- SP#/EN#引脚为输入端。
若8259A级联，由其确定是主片（SP#/EN#       为高）或从片 （SP#/EN# 为低）。

由ICW4设置
```
### 引入中断请求方式

#### 边沿触发方式
```
8259A将中断请求输入端出现的上升沿作为中断请求信号。

- ICW1设置
```
#### 电平触发方式
```
中断请求端出现的高电平是有效的中断请求信号。

- ICW1设置
```
#### 中断查询方式
```
中断查询方式的特点：
    - 8259A不使用INT向CPU发中断请求信号。
    - CPU内部的中断允许触发器复位，禁止外部对CPU的中断请求。
    - CPU要使用软件查询来确认中断源。

查询软件：关中断、送查询命令、读取查询字。
```
## 4.初始化

```
8259A的命令控制字包括两类

初始化命令字和操作命令字

初始化命令字：一般在系统复位后的初始化编程中设置，用于确定8259A的基本工作方式，设置以后一般保持不变

初始化编程：指系统在上电或复位后对可编程器件进行控制字设定的一段程序

操作命令字：是在初始化以后应用程序随时写入的，它实现对8259A的状态，中断方式和过程的动态控制，在工作中可随时写入操作命令字，以修改某些控制方式
```

### 初始化编程
```
8259A开始工作前，必须进行初始化编程；
给8259A写入初始化命令字ICW。
```
### 中断操作编程
```
在8259A工作期间；
可以写入操作命令字OCW将选定的操作传送给8259A，使之按新的要求工作；
还可以读取8259A的信息，以便了解它的工作状态。
```
## 5.初始化命令字
```
8259A有两个连续的端口地址
偶地址较低，奇地址较高

初始化命令字ICW1～ICW4必须按照顺序填写；
- ICW1写入偶地址端口，ICW2～ICW4写入奇地址端口。
```
### ICW1:（*芯片控制初始化命令字*） 

![23](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/23.png)

```
- A0=0 偶地址端口
- D7       D6 D5 ：8086系统中不使用，设置1和0都可以
- D4：D4=1，作为OCW1的标识位，用与区分OCW2和OCW3，因为二者也是写到偶地址端口的
- D3：设置中断请求方式。边沿触发/电平触发
- D2：8086系统中不使用，设置1和0都可以
- D1：规定单片或级联方式：SNGL＝1，单片方式；SNGL＝0，级联方式
- D0：8086系统中设置为1，用来指出后面还将要设置ICW4
```
### ICW2（中断类型号初始化命令字）

![24](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/24.png)

```
中断类型号的高五位也就是ICW2的高五位，低三位的值则却决于引入中断的引脚序号
 ICW2是任选的；一旦ICW2确定下来，IR0-IR7所对应的八个中断类型号也就确定了
 ICW2高5位影响中断类型码，而中断类型码的低3位由IR0～IR7决定。

例：ICW2为20H，8259A的IR0-IR7的中断类型码为20H,21H,22H…,27H
```
### ICW3（主片/从片初始化命令字）



```
系统中包含多片8259A时，才需要ICW3。
由ICW1的D1位（SNGL）指示，SNGL=0时，才需要设置ICW3。
```
如是主片,则ICW3的格式如下： 

![25](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/25.png)


```
IRi＝1说明对应的IRi引脚上接有从片；

IRi＝0则表示IRi没有连接从片
```
如是从片，则ICW3的格式如下： 

![26](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/26.png)


```
ID2～ID0编码说明从片INT引脚接到主片哪个IR引脚
```
### ICW4（方式控制初始化命令字）

![27](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/27.png)

```
- ICW1的第D0位为1时，才写入ICW4；
16位或32位系统必须设置ICW4。
```


```
- D7-D5:全为0，作为ICW4的标识码

- D4:嵌套方式:

    特殊全嵌套方式（SFNM＝1）
    普通全嵌套方式（SFNM＝0）

- D3:数据线的缓冲方式：

    缓冲方式（BUF＝1）
    非缓冲方式（BUF＝0） 

- D2:

    BUF=0时,M/S#不起作用

    BUF=1时主片/从片选择：

    主片（M/S#=1）
    从片（M/S#=0）

- D1:中断结束方式：

    自动中断结束（AEOI＝1）
    非自动中断结束（AEOI＝0）

- D0:微处理器类型：

    16位或32位系统（mPM＝1）
    8位系统8080/8085（mPM＝0）
```
### 初始化流程
```
8259A在进入工作之前，必须先使用初始化命令字将每片8259A进行初始化。8259A的初始化流程应该遵循固定的次序

① ICW1写入偶端口，ICW2～ICW4写入奇端口；

② ICW1～ICW4的设置次序固定；

③ ICW1和ICW2必须设置，ICW3和ICW4非必须 ；16位和32位系统中ICW4必须设置，多8259A级联时，ICW3要设置

④ 在级联时，主片和从片各设置ICW3；注意其ICW3的格式并不相同
```
## 6.操作命令字
```
操作命令字是在应用程序中设置的

设置次序没用要求

- OCW1写入奇地址端口

- OCW2 OCW3写入偶地址端口
```
### OCW1（中断屏蔽操作命令字）

![28](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/28.png)

```
中断屏蔽操作命令字：内容写入中断屏蔽寄存器IMR
- Di＝Mi对应IRi为1禁止IRi中断；为0允许IRi中断。各位互相独立。
```
### OCW2（优先级循环方式和中断结束方式操作命令字）

![29](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/29.png)

```
- R、SL和EOI配合使用产生中断结束EOI命令和改变优先权顺序
- D4D3=00  为OCW2的标志位
- L2～L0的3位编码指定IR引脚 
```

![30](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/30.jpg)

### OCW3（状态操作命令字）

![31](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/31.png)

```
（1）设置和撤销特殊屏蔽方式

（2）设置中断查询方式

（3）设置对内部寄存器的读出命令
```

```
- ESMM称为SMM的允许位
    - SMM为特殊屏蔽模式位
    - ESMM为特殊屏蔽模式允许位
```
![32](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/32.jpg)

P：查询方式位

![33](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/33.jpg)

RR RIS

![34](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/34.jpg)


## 7.使用举例


# Ⅶ、8253

## 定时信号
```markdown
一般来说，定时信号可用软件和硬件两种方法得到

软件定时:

根据所需要的时间常数来设计一个延时子程序；
当延时时间较长时，可循环该延时子程序

硬件定时

计数器/定时器：计数时不会占用CPU的资源
```

## 工作原理

![8253_1](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/8253_1.png)

```markdown

计数器：在设置好计数初值（即定时常数）后，便开始减1计数，减为0时，输出一个信号

计数器在减到0以后，输出一个信号便结束了，除非重新触发
--------------------------------------------
定时器：在设置好定时常数后，便进行减1计数，并按定时常数不断地输出为时钟周期整数倍的定时间隔

定时器减到0以后，自动恢复初值重新奇数，并不断产生信号


3个独立的16位计数器通道；
共用1个控制寄存器和1个状态寄存器（只有8254有状态寄存器）。
每个计数器有6种工作方式；
按二进制或十进制（BCD码）计数。
```


## 编程结构

8253 内部没有状态寄存器

![8253_2](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/8253_2.png)

### 计数器
```markdown

8253内部有三个计数器：计数器0，计数器1，计数器2，其结构完全相同

每个计数器的输入和输出都决定于设置控制寄存器中的控制字，他们共用一个控制寄存器，但相互之间完全独立

内部结构

    三个引脚：时钟输入CLK,门控信号输入端GATE,输出端OUT
    内部部件：16位计数初值寄存器CR,计数执行部件CE,输出锁存器OL

    执行部件实际上就是一个16位的减法计数器，其起始值就是初值寄存器的值，初值寄存器的值是通过程序设置的

    输出锁存器OL用来锁存计数执行部件CE的内容，从而使得CPU可对此进行读操作

    - CE CR OL 都是十六位的寄存器，但也可用作为8位寄存器来用

    计数器的工作方式决定于控制寄存器中的控制字
```

### 工作过程
```markdown

\1. 设置8253\8254的工作方式；

\2. 设置计数初值到计数初值寄存器CR；

\3. 第一个CLK信号使计数初值寄存器的内容置入

计数执行部件CE；

\4. 以后每来一个CLK信号，CE减1； 

\5. OUT端输出一特殊波形的信号；

注：以上计数过程中还受到GATE信号的控制。
```


## 外部信号
```markdown

- CLK0-CLK2：三个计数器的时钟信号

- GATE0-GATE2：三个计数器的门控信号

- OUT0-OUT2：三个计数器的输出信号

- A1,A0：地址线，对三个计数器和控制寄存器进行寻址

        8253有四个端口地址

        - A1A0=00,计数器0
        - A1A0=01，计数器1
        - A1A0=10，计数器2
        - A1A0=11，控制端口

/RD，/RD有效时，CPU对8253的输出锁存器进行读操作

/WR,/RD有效时，CPU对8253的一个计数器写入计数初值或对控制寄存器写入控制字

- CS：/CS有效时，/WR,/RD才会有效
```

## 控制寄存器与控制字

8253内部的三个寄存器共用一个控制寄存器，通过对控制寄存器写入控制字，就可使得三个计数器处于不同的工作模式，控制端口是只写的；

### 模式设置控制字

模式控制字：用来设置三个计数器的工作模式

![8253_3](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/8253_3.png)


```markdown
- BCD位：计数初值的格式

此位为0，后面设置的计数初值为BCD码格式，0-9999；
此位为1，后面设置的计数初值为二进制格式，为0-FFFFH

- M2 M1 M0：模式选择位

000 模式0
001 模式1
X10 模式2
X11 模式3
100 模式4
101 模式5

- RW1 RW0 读写指示位

00 对计数器进行锁存操作，使当前计数值在输出锁存器中锁定，以便读出
01 只读/只写低八位
10 只读/只写高八位
11 先读/写低八位，再读/写高八位

- SC1 SC0 选择计数器

设置模式控制器字时，指出时对哪一个计数器进行设置

00 计数器0
01 计数器1
10 计数器2
11 读出控制字的标识码
```

### 关于的控制字说明
```markdown
1、8253/8254只有一个工作方式控制字，但是对每个计数器而言，它们的工作方式控制字内容一定各不相同（前两位不同），所用各计数器的控制字需要分别设置，先后不计。

2、在工作方式控制字被设置之后，随后必须紧接着给计数器预设置计数初值，计数器方可开始工作。

8253/8254初始化的工作有两个内容：

（1）首先向控制寄存器写入控制字，以选择计数器（3个计数器之一），确定工作方式（6种方式之一），指定计数器计数初值的长度和装入顺序以及计数值的码制（BCD或二进制码）。

（2）然后向已选定的计数器按控制字要求写入计数初值。
```


### 读出控制字

读出控制字：用来读取计数器当前的计数值
```markdown
每个计数器的当前计数值可以被读取，因为计数值是不断变化的，所以在读取前要先进行锁存。读出控制字就是起锁存作用的，所以也叫做锁存命令
- D6 D7 D0：D7D6=11为读出控制字的标识码；D0=0必须是这样设置
/COUNT：如果为0，则将所选计数器的当前计数值进行锁存，以便后面读取
/STATUS：如果为零，则将所选计数器的状态进行锁存
- D3D2D1：分别对应于计数器2，1，0。在一个时刻只能对一个计数器进行锁存
```


## 编程命令

对8253的编程没有顺序规定，非常灵活

### 三条原则

```
对计数设置初值前必须先写控制字
初值设置时，要符合控制字中的格式规定
要读计数器的当前值和和状态字，必须用控制字先进行锁存
```

### 编程命令

#### 写入命令——针对控制寄存器
```markdown
设置控制字命令，设置初值命令，锁存命令
一个计数器在工作之前，需要先设置控制字对所选择的计数器设定工作模式和计数格式；
设置初值命令用来给出计数的初值
锁存命令是配合读出命令使用的。在读取计数值时，必须先用锁存命令将当前计数值在输出锁存器中锁住，否则，在读数时，计数器的值在变化，就得到一个不确定的结果
当锁存命令到来时，计数执行部件到某一个值，因为锁存器是跟随计数执行部件工作的，所以锁存器中为同一值，此时这一计数被锁住
- CPU将此锁定值读走之后，锁存器自动失效，于是又跟随计数执行部件变化。
在锁存和读出计数值的过程中，计数执行部件仍在不停地作减一计数
```
#### 读出命令——针对计数器
```markdown
读出命令用来读取8253的某个计数器的当前计数值
读取计数器的值之前必须先锁存，再读取
```
## 工作模式

### 基本原则
```markdown
写入控制字时，所有的控制逻辑电路立即复位，输出端OUT进入初始状态（高或低电平）
初始值写入之后，要经过一个时钟上升沿和一个下降沿，计数执行部件才开始计数
通常，在时钟脉冲CLK上升沿时，门控信号GATE被采样
在时钟脉冲的下降沿，计数器作减一操作。

其中0是最大初值，1是最小初值；
```
### 模式0——计数结束产生中断

不是连续波形，产生中断；计数期间为低电平，结束为高电平。

![8253_00](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/8253_00.png)

```markdown
①控制字写入之后，OUT变低；初值装入后，要经过1个CLK的周期（1个上升沿和1个下降沿）后，计数器才开始计数，所以，输出OUT要经过N+1个时钟周期后才有输出；

②输出OUT的有效电平为高电平，并可同时触发中断请求；

③门控GATE的作用：高电平时计数，低电平或下降沿时停止计数；

④CW为写入控制字，N=4表示写入初值，计数值一次有效。
```



### 模式1：可编程单稳态触发器

周期性波形，计数期间为低电平，其余为高电平。

![8253_11](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/8253_11.png)

```markdown
①控制字和初值装入后，OUT变高，在门控GATE的上升沿触发下，经过1个CLK的上升沿和1个下降沿后，计数器开始从初值减1计数，同时使OUT=0；当计数结束（归0）时，OUT=1，使输出产生1个宽度为TW=N×TCLK的负脉冲——单稳态触发器。

②在GATE的上升沿触发下，输出可再次产生1个宽度为TW负脉冲——可重复触发。
```
### 模式2：分频器

连续波形产生负脉冲，在最后一个计数期间为低电平，其余为高电平。

![8253_22](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/8253_22.png)

```markdown
①控制字装入后，OUT=1为初始状态。

②初值装入后，经过1个CLK的周期，计数器开始从初值减1计数，计到1（不是0）时，使输出OUT=0并保持1个CLK周期，然后OUT=1，开始下一个新的计数周期，使输出为CLK的时钟1/N分频信号，占空比q=（N-1）/N。

③门控GATE的作用：高电平时计数，低电平停止计数；GATE再次变高后从初始值重新计数；而在GATE=1时，计数完成之后自动重新装入初值，循环计数。

④如果计数过程中写入新值.不影响当前计数.完成后重新装入新值
```
### 模式3：方波发生器

周期性方波（占空比1:1）。

![8253_33](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/8253_33.png)

```markdown
特点与方式2类似，主要区别：输出方波，其占空比q为

①当N为偶数时，q=0.5；

②当N为奇数时，q=(N+1)/2N。
```





### 模式4：软件触发的选通信号发生器

单次波形输出，计数结束后输出一个CLK周期的低电平，其余为高电平，不能自动循环。

![8253_44](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/8253_44.png)

```markdown
①初值装入后，经过1个CLK的周期，计数器开始从初值减1计数，计数结束（归0）时，使输出OUT产生一个宽度为1个CLK周期的负脉冲——选通信号。

②（用指令）重新装入初值后，经过N+1个CLK周期，又可使OUT产生一个选通信号——（用软件）可重复触发。

③门控GATE的作用：高电平时计数，低电平时停止计数。
```

### 模式5：硬件触发的选通信号发生器

单次波形输出，波形特征同方式4，但重置初值和GATE上升沿之后可重新计时。

![8253_55](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/8253_55.png)

```markdown
①初值装入后，在GATE的上升沿的触发下，经过1个CLK的周期，计数器开始从初值减1计数，计数结束（归0）时，使输出OUT产生一个宽度为1个CLK周期的负脉冲——选通信号。

②用GATE的上升沿可重新触发，使OUT产生一个选通信号——（用硬件）可重复触发。
```



### 8253工作模式小结
```markdown
模式2、4、5的输出波形是相同的，都是宽度为一个CLK周期的负脉冲。

但模式2是连续工作，模式4由软件（设置计数值）触发启动，模式5由门控脉冲触发启动

写入计数值后才能开始计数

模式0、2、3、4在写入计数值后，计数过程就开始了

模式1、5需要外部触发启动，才开始计数

6种方式中只有方式2、3是连续计数，其他4种方式都是一次计数，要继续工作需要重新启动，方式0、4由写入计数值（软件）启动，方式1、5要由外部信号（硬件）启动。

```

## 应用举例

```assembly
;假设端口是
0123H;control
0120H;0
0121H;1
0122H


CNT0：
MOV DX,0123H            ;初始化
MOV AL,34H
OUT DX,AL
MOV DX,0120H            ;写入计数初值
MOV AX,20000            ;使用AX寄存器，分为低8位和高8位，即AL和AH
OUT DX,AL
MOV AL,AH
OUT DX,AL


CNT1：
MOV DX,0123H            ;初始化
MOV AL,56H
OUT DX,AL
MOV DX,0121H            ;写入计数初值
MOV AX,200              ;这里AX可以直接写AL,200用八位寄存器就够   
OUT DX,AL


CNT2：
MOV DX,0123H            ;初始化
MOV AL,B0H
OUT DX,AL
MOV DX,0122H            ;写入计数初值
MOV AX,10000
OUT DX,AL
MOV AL,AH
OUT DX,AL

```





# 80C51

# 特点

```markdown
- 8位微处理器
- 物理结构上具有两个寻址空间:寻址64KB程序空间，寻址64KB数据空间
- 分类:
	无片内ROM型：80C31 必须代价EPROM才能使用
	带片内ROM型
		片内EPROM型：87C51
		片内FLASH型：89C51
		片内掩膜ROM型：80C51
		片内一次性编程（OTP）ROM：97C51
- 存储器配置：程序存储器和数据存储器分离，使用不同的指令和寻址方式进行访问
	寻址64KB程序空间，寻址64KB数据空间
- 80C51共有111条指令
- 80C51有分为2个中断优先级的5个中断源
- 内部RAM
	4个通用工作寄存区
	32个通用寄存器
	1个位寻址区
- 4个并行IO口（P0-P3）
	P0 P2可作为片外扩展地址总线使用
- 内部集成一个全双工的异步串口接口，可同时发送和接收数据

------------------------------------------------
补充：
单片机按存储结构可分为二类：一类是哈佛结构，另一类是普林斯顿结构。
       ①哈佛结构
       所谓哈佛结构是指程序存储器地址空间与数据存储器地址空间分开的单片机结构，如80C51单片机采用哈佛结构，所以80C51单片机的程序存储器地址空间与数据存储器地址空间是分开的，各有64K存储空间。
       ②普林斯顿结构
       所谓普林斯顿结构是指程序存储器地址空间与数据存储器地址空间合并的单片机结构，如MCS-96单片机采用普林斯顿结构，所以MCS-96单片机的程序存储器地址空间与数据存储器地址空间是合并的，共有64K存储空间。
```

# 结构

## 基本结构

![QQ图片20210626102242](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210626102242.png)

![QQ图片20210626103208](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210626103208.png)

``` markdown
- 80C51中没有单独的地址总线和数据总线，而是与通用并行口中的P0和P2口公用；
	8位数据线，16位地址线
        P0口分时作为低八位地址线和8为数据线用；
        P2口作为高八位地址线
    单片机在进行外部扩展时的地址线和数据线都不是独立的总线，而是与并行口IO共用
    来自网络：
    	8051单片机CPU是几位的?  
    	—— 8位,多少位机一般以数据总线的位数来确定的,8051的数据总线为P0口,8位分别为P0.0~P0.7,有16根地址总线,分别为P0和P2.
    
```

## 内部结构



![QQ图片20210626103507](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210626103507.jpg)



``` markdown
（来自网络）
若除去图中的存储器电路和I/O部件，剩下的便是CPU。它可以分为运算器和控制器两部分。
	运算器功能部件包括算术逻辑运算单元ALU、累加器ACC、寄存器B、暂存寄存器TMP1、TMP2、程序状态字寄存器PSW等。
	控制器功能部件包括 **程序计数器PC** 、指令寄存器IR、指令译码器ID、定时控制逻辑电路CU、**数据指针寄存器DPTR** 、**堆栈指针SP** 及时钟电路等。

（1）运算器
    ①算术逻辑运算单元ALU（Arithmetic Logical Unit）
    ALU可以进行算术、逻辑运算。算术运算有：加、减、乘、除，逻辑运算有：与、或、异或等。
    ②累加器ACC
    累加器ACC的主要功能是在运算前存放一个操作数，运算后存放一个操作结果。80C51系列单片机虽然在结构上仍然以累加器A作为重要部件。但由于内部电路采取了措施，使得累加器A在数据传送、逻辑操作等方面的核心作用有所削弱。数据可以在片内直接/间接地址的存储器之间直接传送，而不必经过累加器A。但，加、减、乘、除算术运算指令的运算结果都存放在累加器A或AB寄存器对中。
    ③暂存器TMP1、TMP2
    由80C51单片机的内部结构框图可知，ALU进行算术逻辑运算前的两个操作数来自暂存器TMP1、TMP2，所以暂存器TMP1、TMP2用于存放运算前的两个操作数。
    ④程序状态字寄存器PSW
    程序状态字寄存器PSW用来存放运算结果的状态标志。PSW寄存器各位的含义如下，其中PSW.1未定义，其它各位说明如下：
        CY：进位标志。它是累加器A的进位位，如果操作结果在最高位有进位（加法）或借位（减法）时置1，否则清0。
        AC：半进位标志。它是低半字节的进位位（累加器A中A3位向A4位的进位），主要用于BCD码调整。低4位有进位（加法时）或向高4位有借位时（减法时），AC是1，否则，AC清0。
        F0：用户定义的状态标志位。可通过软件对它置位、复位或测试，以控制程序的流向。
        RS1、RS0：工作寄存器区选择控制位，用于选择4组工作寄存器之一。可以用软件来置位或清零，以确定工作寄存器区。RS1、RS0与寄存器区的对应关系如下：
        RS1、RS0=00——0区（地址00H~07H）
        RS1、RS0=01——1区（地址08H~0FH）
        RS1、RS0=10——2区（地址10H~17H）
        RS1、RS0=11——3区（地址18H~1FH）
        OV：溢出标志位，用于表示有符号数算术运算的溢出。溢出时OV为1，否则OV为0。
        P：奇偶标志位。每个指令周期都由硬件来置位或清零，以表示累加器A中1的个数的奇偶性。若1的个数为奇数，则P置位；若1的个数为偶数，则清零。
    ⑤寄存器B
    在乘除指令中，用到了寄存器B。
（2）控制器
控制器是控制单片机各种操作的部件，用于完成指令规定的操作。它包括程序计数器PC、指令寄存器IR、指令译码器ID、定时控制逻辑、数据指针寄存器DPTR、时钟发生器、复位电路、堆栈指针SP等。
	①程序计数器 PC
    程序计数器PC为16位寄存器，用于存放下一条要执行指令地址，具有自动加1功能。
    ②指令寄存器IR、指令译码器ID、定时控制逻辑电路
    指令寄存器IR用来暂时存放当前取出的指令，并由指令译码器ID译码，产生相应的译码信号，并传送给定时控制电路，定时控制电路发出各种控制信号控制各器件完成指令规定的操作。
    ③数据指针DPTR
    DPTR为16位寄存器。由于80C51单片机采用哈佛结构，因此，其程序存储器与地址存储器是分开的，程序存储器的地址是由程序计数器PC提供，而数据存储器的地址是由数据指针DPTR提供的，所以DPTR用于存放片外数据存储器及I/O口的地址。
    ④时钟电路
    时钟电路是计算机的心脏，它控制着计算机的工作节奏。
    ⑤复位和复位电路
    计算机在启动运行时都需要复位，复位就是使CPU和系统中的其它部件处于一个确定的初始状态，并从这个状态开始工作。
    ⑥堆栈指针SP
    堆栈指针SP用于存放栈顶单元的地址。
```

# 引脚

![QQ图片20210626105743](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210626105743.png)

``` markdown
Vss(20脚):接地

VCC（40脚）: 主电源+5V

XTAL1（19脚）:接外部晶体的一端。在片内它是振荡电路反相放大器的输入端。在采用外部时钟时，对于HMOS单片机，该端引脚必须接地；对于CHMOS单片机，此引脚作为驱动端。

XTAL2（18脚）: 接外部晶体的另一端。在片内它是一个振荡电路反相放大器的输出端，振荡电路的频率是晶体振荡频率。若需采用外部时钟电路，对于HMOS单片机，该引脚输入外部时钟脉冲；对于CHMOS单片机，此引脚应悬浮。


RST（9脚）: 单片机刚接上电源时，其内部各寄存器处于随机状态，在该脚输入24个时钟周期宽度以上的高电平将使单片机复位（RESET）

 

PSEN（29脚）: 在访问片外程序存储器时，此端输出负脉冲作为存储器读选通信号。CPU在向片外存储器取指令期间，PSEN信号在12个时钟周期中两次生效。不过，在访问片外数据存储器时，这两次有效PSEN信号不出现。PSEN端同样可驱动8个LSTTL负载。我们根据PSEN、ALE和XTAL2输出端是否有信号输出，可以判别80C51是否在工作。

 

ALE/PROG（30脚）:在访问片外程序存储器时，此端输出负脉冲作为存储器读选通信号。CPU在向片外存储器取指令期间，PSEN信号在12个时钟周期中两次生效。不过，在访问片外数据存储器时，这两次有效PSEN信号不出现。PSEN端同样可驱动8个LSTTL负载。我们根据PSEN、ALE和XTAL2输出端是否有信号输出，可以判别80C51是否在工作。

 

EA/VPP（31脚）: 当EA端输入高电平时，CPU从片内程序存储器地址0000H单元开始执行程序。当地址超出4KB时，将自动执行片外程序存储器的程序。当EA输入低电平时，CPU仅访问片外程序存储器。在对87C51EPROM编程时，此引脚用于施加编程电压VPP。

 

输入/输出引脚：

    （1）P0.0—P0.7    (39脚—32脚)

    （2）P1.0—P1.7   （1脚—8脚）

    （3）P2.0—P2.7   （26脚—21脚）

    （4）P3.0—P3.7   （10脚—17脚）
    	P3.0/RXD(串口收)
    	P3.1/TXD（串口发）
```



# 存储器

![QQ图片20210626110555](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210626110555.jpg)

``` markdown
  由于80C51单片机采用哈佛结构，所以其程序存储器和数据存储器是分开的，各有自身的寻址系统、控制信号和功能。
  程序存储器用来存放程序和表格常数；数据存储器通常用来存放程序运行所需要的给定参数和运行结果。
       从实际的物理存储介质来看，80C51有4种存储空间，它们是片内程序存储器、片外程序存储器（MOVC）、片内数据存储器（含特殊功能寄存器）和片外数据存储器(MOVX)。80C51的存储器配置情况如下图所示。
```

![QQ图片20210626105940](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210626105940.png)

``` markdwon
       从逻辑地址空间来看，80C51单片机可分为三部分，即：程序存储器、片外数据存储器、片内数据存储器。这3部分分别使用不同的地址指针，不同的访问指令。因此，下面按逻辑结构介绍80C51的存储器结构。
       （1）程序存储器
       由下图可知，程序存储器以程序计数器PC作地址指针，通过16位地址总线，可寻址的地址空间为0000H~0FFFFH共64K(216=64K)字节，其访问指令为MOVC。用于存放程序指令码与固定的数据表格等。
```

![QQ图片20210626111106](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210626111106.png)

``` markdown
 80C51单片机中内部和外部共64K字节程序存储器的地址空间是统一的。对于有内部ROM的单片机，在正常运行时，应把引脚接高电平，使程序从内部ROM开始执行。当PC值超出内部ROM的容量时，会自动转向外部程序存储器空间。
       （2）片外数据存储器
       由80C51的存储器配置图可知，片外数据存储器以DPTR作为地址指针，通过16位地址总线，可寻址的地址空间为0000H~0FFFFH共64K(216=64K)字节，其访问指令为MOVX。用于存放数据与运算结果。
       （3）片内据存储器
       片内数据存储器的地址空间从00H~FFH共256字节，其访问指令为MOV。其地址可由R0、R1寄存器提供。内部数据存储器是最灵活的地址空间，它分成物理上独立且性质上不同的2个区：00H~7FH单元组成的128字节RAM区，地址为80H~FFH的特殊功能寄存器区（简称SFR区）。
       1）RAM区（00H~7FH）
       又由80C51的存储器配置图可知，RAM区又分为3个区：工作寄存器区、位地址区与数据缓冲区。
       ①工作寄存器区（00H~1FH）
       80C51单片机的内部RAM区结构如80C51的存储器配置图所示。
       ②位地址区（20H~2FH）
       内部RAM的20H~2FH为位寻址区域，见表1所示。这16个单元的每一位都有一个位地址，位地址范围为00H~7FH。通常把各种程序状态标志、位控制变量设在位寻址区内。位寻址区的RAM单元也可以作为一般的数据缓冲区使用。

       						表1 内部RAM区的位地址映像表
```

![QQ图片20210626111229](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210626111229.png)

``` markdwon
 ③数据缓冲区
       数据缓冲区的地址空间从30H~7FH共80个字节单元，用于存放数据与运算结果，如加法运算时，存放加数、被加数及运算和。通常堆栈区也设置在该区内。有些单片机将显示缓冲区设置在该区内。
       2）特殊功能寄存器SFR（80H~FFH）
       80C51单片机内的I/O口锁存器、状态标志寄存器、定时器、串行口、数据缓冲器以及各种控制寄存器统称为特殊功能寄存器，它们离散地分布在内部RAM地址空间（80H~0FFH）内，表2列出了这些特殊功能寄存器的标识符、名称及地址。由表2-2可知累加器ACC、寄存器B、程序状态字PSW、I/O口P0~P3等均为特殊功能寄存器。
       
       
       							表2 特殊功能寄存器SFR
```

![QQ图片20210626111242](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210626111242.png)

``` markdwon
注：带“·”号的寄存器可按字节和按位寻址，其特征是直接地址能被8整除。带“*”号的寄存器是与定时器/计数器2有关的寄存器，仅在80C52系列中存在。下面以一个实例说明单片机的内部存储器。
```

![QQ图片20210626111344](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210626111344.png)

# 时序

``` markdown
震荡周期T:时序中最小的时间单位
	由外接晶体或者输入时钟决定
时钟周期（状态周期）
	晶体振荡器的真当信号经过片内时钟发生器二分频后的信号
	时钟周期是振荡周期的2倍
机器周期
	CPU执行一条指令所需要的时间的基本单位
	51单片机中的机器周期由12个振荡周期构成
	分为六个状态周期（S1-S6）
	每个状态又分为P1和P2两相时钟
指令周期
	CPU执行一条指令所需要的时间，以机器周期位单位
	
	51单片机共111条指令
	单机器周期指令：64个
	双机器周期指令：45个
	四机器周期指令:2个（乘法指令和除法指令）	
```

# 复位

``` markdown
- 在启动时需要复位，使CPU和系统的各个部件处于一种初始状态
- 复位信号从单片机的RST引脚输入，高电平有效，维持至少两个机器周期
- 上电自动复位
- 按键手动复位
```

# 并行I/O口

![QQ图片20210626111834](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210626111834.jpg)

![QQ图片20210626115604](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210626115604.jpg)

``` markdwon
80C51单片机含有4 个8位并行I/O口P0、P1、P2和P3。
每个口有8个引脚，如图2-1所示，共有32个I/O引脚，每一个并行I/O口都能用作输入或输出。
每一条IO引脚都能独立地用作输入或输出，做输出时数据可以锁存，做输入时数据可以缓冲

        各口的第一、第二功能如下：
               I/O口     引脚       第一功能           第二功能
               P0口   P0.0~P0.7    输入与输出       分时的传送地址低8位与数据线
               P1口   P1.0~P0.7    输入与输出       无第二功能
               P2口   P2.0~P2.7    输入与输出       传送地址的高8位
               P3口   P3.0~P3.7    输入与输出       P3.0——RXD：串行口输入端
               P3.1——TXD：串行口输出端
               P3.2——INT0：外部中断0中断请求输入端
               P3.3——INT1：外部中断1中断请求输入端
               P3.4——T0：定时器/计数器0外部输入端
               P3.5——T1：定时器/计数器1外部输入端
               P3.6——WR：外部数据存储器写选通信号
               P3.7——RD：外部数据存储器读选通信号
               
               
       四个通道口都有一种特殊的线路结构，每个口都包含一个锁存器，即特殊功能寄存器P0~P3，一个输出驱动器和两个（P3口有三个）三态缓冲器。这种结构在数据输出时，可以锁存，即在重新输出新的数据之前，口上的数据一直保持不变。但对于输入信号是不锁存的，所以外设欲输入的数据必须保持到取数指令执行（把数据读取后）为止。
       
       
       
       下面分别叙述各个端口的结构、功能和使用方法。
       -------------------------------------------------------------------------------------------
（1）P0口的组成与功能————————三态双向口

       1）位结构
       在访问外部存储器时，P0口是一个真正的双向数据总线口，并分时送出地址的低8位。
       它包含两个输入缓冲器、一个输出锁存器以及输出驱动电路、输出控制电路。
       输出驱动电路由两只场效应管V1和V2组成，其工作状态受输出控制电路的控制。输出控制电路包括与门、反相器和多路模拟开关MUX。
       P0口既能用作通用I/O口（需要上拉电阻），又能用作地址/数据总线（不需要上拉电阻）。
       
       2）作为通用I/O口
       P0口作为通用I/O口使用时，CPU令控制信号为低电平。这时多路开关MUX接通B端即输出锁存器的 端，同时使与门输出低电平，场效应管V1截止，因而输出级为开漏输出电路。

           ①作为输出口
           当用P0口输出数据时，写信号加在锁存器的时钟端CL上，此时与内部总线相连的D端其数据经反相后出现的 端上，再经V2管反相，于是在P0口引脚上出现的数据正好是内部总线上的数据。由于输出级为开漏电路，所以用作输出口时应外接上拉电阻。
           ②作为输入口
           当P0口用于输入数据时，要使用端口中的两个三态输入缓冲器之一。这时有两种工作方式：读引脚和读锁存器。
           当CPU执行一般的端口输入指令时，“读引脚”信号使图2-4中下面一个缓冲器开通，于是端口引脚上的数据经过缓冲器输入到内部总线上。
           当CPU执行“读一修改一写”一类指令时，“读锁存器”信号使图2-4上面一个缓冲器开通，锁存器Ｑ端的数据经缓冲器输入内部数据总线。
           在P0口作为输入口使用时，必须首先向端口锁存器写入“1”。这是因为当进行读引脚操作时，如果V2是导通的，那么不论引脚上的输入状态如何，都会变为低电平。为了正确读入引脚上的逻辑电平，先要向锁存器写1，使其 端为0，V2截止。该引脚成为高阻抗的输入端。
           
       3）作为地址/数据总线
       P0口还能作为地址总线低8位或数据总线，供系统扩展时使用。这时控制信号为高电平，多路开关MUX接通A端。有两种工作情况：一种是总线输出，另一种是外部数据输入。作为总线输出时，从“地址/数据”端输入的地址或数据信号通过与门驱动V2，同时通过非门驱动V2，结果在引脚上得到地址或数据输出信号。
       作为数据总线输入数据时，从引脚上输入的外部数据经过读引脚缓冲器进入内部数据总线。对于80C51、87C51单片机，P0口能作为I/O口或地址/数据总线使用。对于80C31单片机，P0口只能用作地址/数据总线。
       综上所述，P0口既可以作为地址/数据总线口，这时它是真正的双向口，也可作通用的I/O口，但只是一个准双向口。准双向口的特点是：复位时，口锁存器均置“1”，8根引脚可当一般输入线使用，而在某引脚由原输出状态变成输入状态时，则应先写入“1”，以免错读引脚上的信息。一般情况下，P0口已当作地址/数据总线口使用时，就不能再作通用I/O口使用。


       -------------------------------------------------------------------------------------------
（2）P1口组成与功能————————准双向口

       P1口只用作通用I/O口，其一位结构图如图所示。与P0口相比，P1口的位结构图中少了地址/数据的传送电路和多路开关，上面一只MOS管改为上拉电阻。
       P1口作为一般I/O的功能和使用方法与P0口相似。当输入数据时，应先向端口写“1”。它也有读引脚和读锁存器两种方式。所不同的是当输出数据时，由于内部有了上拉电阻，所以不需要再外接上拉电阻。
       P1口作为输入口使用时，有两种工作方式：读端口   读引脚
       	读端口:实际上并不从外部读入数据，只是把端口锁存器中的内容读入到内部总线，经过某种运算和变换后，再写回端口锁存器；
       	读引脚:真正地把外部的输入信号读入到内部总线。
       	
       
       
       -------------------------------------------------------------------------------------------      
（3）P2口的组成与功能————————准双向口

		当系统中接有外部存储器时，P2口可用于输出高8位地址，若当作通用I/O口用，P2口则是一个准双向口。因此说P2口能用作通用I/O口或地址总线，其一位的结构如图所示。
       ①作为通用I/O口
       当控制信号为低电平时，多路开关接到B端，P2口作为通用I/O口使用，其功能和使用方法与P1口相同。
       ②作为地址总线
       当控制端输出高电平时，多路开关接到A端，地址信号经反相器、V从引脚输出。这时P2口输出地址总线高8位，供系统扩展使用。
       对80C51、87C51单片机，P2口能作为I/O口或地址总线作用。对于80C31单片机，P2口只能用作地址总线。
      
     -------------------------------------------------------------------------------------------     
（4）P3口组成与功能———————多功能口

	P3口能作通用I/O口，同时每一引脚还有第二功能。P3口的一位结构如图2-7所示。
    作为通用I/O口：当“第二功能输出”端为高电平时，P3口用作通用I/O口。这时与非门对于输入端Q来说相当于非门，位结构与P2口完全相同，因此P3口用作通用I/O口时的功能和使用方法与P2口、P1口相同。
    用作第二功能： 当P3口的某一位作为第二功能输出使用时，应将该位的锁存器置“1”，使与非门的输出状态只受“第二功能输出”端的控制。“第二功能输出”端的状态经与非门和驱动管V输出到该位引脚上。
    当P3口的某一位作为第二功能输入使用时，该位的锁存器和“第二功能输出”端都应为“1”，这样，该位引脚上的输入信号经缓冲器送入“第二功能输入”端。
    
    
    
    
    
    
    
    至此，可以对组成一般单片机应用系统时各个并行口的分工小结如下：
    P0口：分时的用作地址低8位与数据线，低8位地址由PC低8位或DPL提供。
    P1口：按位可编址的输入输出口。
    P2口：地址线的高8位，高8位地址由PC高8位或DPH提供。
    P3口：双功能口，若不用第二功能，可作为一般的I/O口。
```



# 定时器/计数器

``` markdown
- 80C51 单片机内部有两个可编程定时器/计数器，T0和T1
- 他们的工作方式指令对相应的特殊功能寄存器编程来设定，设置后用作定时器或计数器
- 定时器/计数器的硬件组成就是：双字节加法计数器TH和TL
- 作定时器使用时，计数器脉冲由单片机内部振荡器提供,计数频率为震荡频率的12分之一，即每个机器周期加1
- 作计数器使用时，计数脉冲由P3口的P3.4（或P3.5）即T0(或T1)引脚引入，外部脉冲的下降沿触发计数，计数器在每个机器周期的S5P2期间采样外部脉冲。
		若一个周期的采样值为1，下一个周期的采样值为0，则计数器加1，故识别一个从0到1的跳变需要两个机器周期
```

``` markdown
工作原理：
加1计数器输入的计数脉冲有两个来源，一个是由系统的时钟振荡器输出脉冲经12分频后送来，一个是T0或T1引脚输入的外部脉冲源。每来一个脉冲计数器加1，当加到计数器全为1时，再输入一个脉冲就使计数器回零，计数器的溢出使TCON中的TF0或TF1置1，向CPU发出中断请求（定时/计数器中断允许时）。如果定时/计数器工作于定时模式，则表示定时时间已到，如果工作于计数模式，则表示计数值已满。

可见，由溢出时计数器的值减去计数初值才是加1计数器的计数值。

设置为定时器模式时，加1计数器是对内部机器周期计数（1个机器周期等于12个振荡周期，即技术频率为晶振频率的1/12）。计数值N乘以机器周期Tcy就是定时时间t。

例：假设计数50个数，那么定时时间为：   （定时时间（μs）=计数数X1/(晶振频率)X12）。

16位寄存器能够计数的最大时间为65536μs。

设置为计数模式时，外部事件计数脉冲由T0或T1引脚输入到计数器。在每个机器周期的S5P2期间采样T0、T1引脚电平。当某周期采样到一高电平输入，而下一周期有采样到一低电平时，计数器加1，更新的计数值在下一机器周期得S3P1期间装入计数器。由于检测一个从1到0下降沿需要2个机器周期，因此要求被采样的电平至少要维持一个机器周期。当晶振频率为12MHz时，最高计数频率不超过1/2MHz，即计数脉冲的周期要大于2μs。
```

TMOD：定时器/计数器的工作方式

TCON：定时器/计数器的启动运行

80C51单片机定时/计数器的工作由两个特殊功能寄存器控制。**TMOD用于设置其工作方式；TCON用于控制其启动和中断申请**。

## 方式控制寄存器 TMOD

地址：89H

**工作方式寄存器TMOD用于设置定时/计数器的工作方式，**低四位用于T0，高四位用于T1。其格式如下：

![QQ图片20210627094607](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210627094607.png)

``` markdown
GATE：门控位。GATA=0时，只要用软件使TCON中的TR0或TR1为1，就可以启动定时/计数器工作；GATA=1时，要用软件使TR0或TR1为1，同时外部中断引脚也为高电平时，才能启动定时/计数器工作。

C//T：定时/计数模式选择位。C/=0时为定时模式；C/=1时为计数模式。

M1M0：工作方式设置位。定时/计数器有四种工作方式，由M1M0进行设置。
```

![QQ图片20210627094610](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210627094610.png)

## 运行控制寄存器 TCON

TCON的低4位用于控制外部中断。TCON的高4位用于控制定时/计数器的**启动和中断申请**。其格式如下：

![QQ图片20210627094643](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210627094643.png)

``` markdown
TF1（TCON.7）：T1溢出中断请求标志位。T1计数溢出时由硬件自动置TF1为1。CPU响应中断后TF1由硬件自动清0.T1工作时，CPU可随时查询TF1的状态。所以，TF1可用作查询测试的标志。TF1也可以用软件置1或清零，同硬件置1或清0的效果一样。

TR1（TCON.6）：T1运行控制位。TR置1时，T1开始工作；TR1置0时，T1停止工作。TR1由软件置1或清零。所以，软件可控制定时/计数器的启动与停止。

TF0（TCON.5）：T0溢出中断请求标志位，其功能与TF1类同。

TR0（TCON.4）：T0运行控制位，其功能与TR1类同。
```

![QQ图片20210627094923](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210627094923.png)

### 方式0

![QQ图片20210627095053](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210627095053.png)

![QQ图片20210627095059](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210627095059.png)

### 方式1

![QQ图片20210627095112](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210627095112.png)

### 方式2

![QQ图片20210627095120](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210627095120.png)

### 方式3

![](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210627095127.png)

# 中断

## 中断的概念

``` markdown
- 单片机与外设交换信息可采用查询方式和中断方式
- 中断就是CPU暂时终止当前正在执行的程序而转去执行中断服务子程序，所有中断的方式CPU效率高！


- 中断类型
	- 屏蔽中断
		又名：直接中断
		通过指令使中断系统与外界隔开，使外接发来的中断请求不起作用，不引起中断。
	- 非屏蔽中断
		计算机一定要处理的中断方式，不能用软件来加以屏蔽
		一般用与程序中掉电等紧急情况
	- 软件中断
		一种用指令系统中专门的中断指令来实现的一种中断，一般用与程序中断点的设置，以便于程序的调试！
		
中断源:
	引起中断的原因，或是能发出中断申请的来源
	
中断系统的任务：
	对于中断申请开放或屏蔽（开中断和关中断）
		只有在开中断的情况下，才有可能接受中断源的申请
	中断的排队
		中断优先级问题
	中断的响应
		单片机在响应了中断的申请后，应使CPU从主程序转去执行中断服务子程序；
		同时要把断点地址送人堆栈进行保护，以便在执行完中断服务子程序后能返回到原来的断点继续执行主程序。
		中断系统还要能够确定各个被响应中断源的中断服务子程序的入口
	中断的撤销
		在响应中断请求之后，返回主程序之前，中断申请应该撤销；
		否则就等于中断申请仍然存在，这将会影响其他中断申请的响应；
        80C51只能对一部分中断申请在响应后自动撤销
        
```



## 中断申请与控制

``` markdown
5个中断源

- 两个外部中断
  - 两个外部中断源分别从/INT0（P3.2）和/INT1（P3.3）引脚输入
  - 外部中断请求信号：
  - 电平输入方式
    - /INT0（P3.2）和/INT1（P3.3）引脚检测到低电平为有效的中断申请
  - 负边沿输入方式
    - /INT0（P3.2）和/INT1（P3.3）引脚检测到从1到0的负脉冲跳变
- 两个定时器/计数器中断
  - 内部中断
  - 当T0或T1溢出（全1变成全0）时发出中断申请
- 一个串行口中断
  - 内部中断
  - 在串行口，每接受或发送完一组数据后自动发出的中断申请
```



### TCON寄存区

- 地址88H
- 其中各位都可以位寻址，位地址88H-8FH；
- 定时器/计数器溢出中断和外部中断的申请标志，在CPU响应中断之后会自动撤除

![QQ图片20210626140324](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210626140324.jpg)

### SCON寄存区

- 地址98H
- 位寻址：98H-9FH
- 串行口的中断申请标志是由TI和RI相或以后产生的，并且串行口中断申请在得到CPU响应之后不会自动撤除

![QQ图片20210626140340](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210626140340.jpg)

### IE 中断允许寄存区

- 地址A8H
- 位寻址:A8H-AFH
- 80C51在复位时，IE各位的状态都是0，所以CPU处于关中断的状态

![QQ图片20210626140355](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210626140355.jpg)

### IP 中断优先级寄存器

- 地址B8H
- 位寻址：B8H-BCH
- IP寄存器的某一位为1则相应的中断源为高优先级
- IP寄存器的某一位为0则相应的中断源为低优先级

![QQ图片20210626140414](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210626140414.jpg)

![](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210626140414.jpg)

## 中断响应

![QQ图片20210627091716](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210627091716.jpg)

## 中断响应的条件

``` markdown
①、中断源有中断请求；
②、此中断源的中断允许为位1；
③、CPU开中断（即EA=1）。
```

以外部中断0为例：

       主程序中需要的代码：

``` C
EA=1；//打开总中断开关
EX0=1；//开外部中断0
IT0=0/1；//设置外部中断的触发方式
```



        中断服务函数： 

``` C
//void 函数名（）interrupt(中断服务子程序) 0(优先级)
void int0 () interrupt 0 

{
　　do anything that you want

}
```

# 串口通信

## 波特率

![QQ图片20210627095510](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210627095510.png)
## 同步与异步

![QQ图片20210627095754](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210627095754.png)

![QQ图片20210627095758](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210627095758.png)

![QQ图片20210627095800](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210627095800.png)

![QQ图片20210627095802](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210627095802.png)

![QQ图片20210627095808](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210627095808.png)
## 串口结构

![QQ图片20210627095919](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210627095919.png)



## 串行口控制寄存器 SCON



![QQ图片20210627100401](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210627100401.png)

![QQ图片20210627100403](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210627100403.png)

![QQ图片20210627100406](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210627100406.png)

![QQ图片20210627100408](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210627100408.png)

## 特殊功能寄存器 PCON

``` markdown
只有D7位与串口工作有关
D7（SMOD）=1 串行口传送的波特率加倍
```



## 串行口的四种工作方式

![QQ图片20210627100702](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210627100702.png)

![QQ图片20210627100705](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210627100705.png)

![QQ图片20210627100707](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210627100707.png)

![QQ图片20210627100709](https://gitee.com/murphyhou/picgo/raw/master/microcomputer_image/QQ%E5%9B%BE%E7%89%8720210627100709.png)



# DA



# AD