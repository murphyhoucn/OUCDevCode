# 第一章 绪论

```markdown
8086 ——16位处理器
数据总线DB——16位
地址总线AB——20位
```

## 存储器
**内存的读步骤**

``` markdown
1.CPU把要读的内存单元的地址放到AB上
2. CPU发出读命令
3. 内存将数据从指定单元读到DB上
4. CPU从DB上取回数据
```

**内存的写操作**

``` markdown
1. CPU把要写的内存单元的地址放到AB上
2. CPU把要写的数据放到DB上
3. CPU发出写的命令
4. 数据被内存写到指定的单元
```
```markdown
外存中的数据使用前必须先读到内存中，然后CPU才能访问
```


## 总线

```markdown
总线宽度：一次可以同时传输的数据位数
8086，数据总线宽度为16位，地址总线宽度位20位
```

## IO

## 溢出
```markdown
异号相加不会溢出
同号相加可能溢出
```

## 二进制

## BCD码

``` markdown
用二进制编码表示十进制数
一位十进制数需要用四位二进制编码表示
压缩BCD码——一个字节表示两位十进制数
非压缩BCD码——一个字节表示一位十进制数（使用低四位）
```



# 第二章 8086

## 性能指标

```markdown
字长——CPU能够同时处理的数据的位数，也称为数据位宽
8086——16位
主频——时钟频率
```



## 8086的编程结构

``` markdwon
16位数据线；
20位地址线——寻址空间:1MB（2^20）
寄存器：数值逻辑部件，用来暂存数码和信息；由触发器和门电路阻成；
```



## **总线接口部件BIU**

### 功能
```markdown
1. 从内存取指令到指令队列
2. CPU执行指令时，BIU配合执行部件从指定内存单元或外设端口中取数据，将数据传送给执行部件
3. BIU配合执行部件把操作结果传送到指定的内存单元或外设接口
```

### 组成

``` markdown
a) 16位段地址寄存器（sgement）——4个
    i) CS CODE
    ii) DS DATA
    iii) ES EXTRA	
    iv) SS STACK
b) 16位指令指针寄存器——IP（instruction pointer）
c) 20位地址加法器
    i) 用来产生20位的地址
        One. 8086用20位地址寻址1MB的内存，但是8086内部的寄存器都是16位的
        Two. 地址加法器就是根据16位寄存器提供的信息计算出20位的物理地址
            First. CS左移四位再与IP相加
d) 6字节的指令队列缓冲器
    i) 指令队列缓冲器——CPU在执行指令的同时，从内存中取下面一条指令或几条指令放在指令队列中


```
### BIU的执行方式
``` markdown
| 顺序执行方式：功能部件交替工作，按顺序完成指令的执行过程
| 并行流水线方式：各功能部件并行工
```
## **执行部件EU**

### 组成

```markdown
算数逻辑部件ALU

16位的通用寄存器——4个

    AX——累加器

    BX

    CX

    DX

		16位通用寄存器可以当作8位来使用，高八位和低八位

16位的专用寄存器——4个

    BP——BASE POINTER基数指针寄存器
    SP——STACK POINTER堆栈指针寄存器
    SI——SOURCE INDEX源变址寄存器
    DI——DESTINATION           INDEX目的变址寄存器。

16位标志寄存器——九个使用，七个未用

状态标志位——6个

    | SF   | Sign flag            | 符号标志       | 与运算结果的最高位相同，运算结果为正数SF=0,运算结果为负数，SF=1
    | ZF   | Zero flag            | 零标志         | 运算结果为0，ZF=1，运算结果为非零，ZF=0 
    | PF   | Parity flag          | 奇/偶标志位    | 运算结果中，低八位中所含1的个数为偶数，PF=1；低八位中所含1的个数为奇数，PF=0
    | CF   | Carry flag           | 进位标志位     | 加法运算——最高位产生进位，CF=1；减法运算——最高位产生借位,CF=1
    | AF   | Auxiliary carry flag | 辅助进位标志位 | 加法运算——第三位往第四位进位，AF=1；减法运算——第三位从第四位借位，AF=1
    | OF   | Overflow flage       | 溢出标志位     | 产生溢出——OF=1

控制标志位——3个

    | DF   | Direction flag        | 方向标志     | 控制串操作指令用的标志：DF=0，串操作过程中地址会不断增值；DF=1，串操作过程中，地址会不断减值
    | IF   | Interrupt enable flag | 中断允许标志 | 控制可屏蔽中断用的标志：IF=0，CPU不能相应可屏蔽中断的中断请求；IF=1，CPU可接受可屏蔽中断的中断请求
    | TF   | Trap flag             | 跟踪标志     | TF=1，CPU按跟踪方式，执行指令
```

## **总线周期（机器周期）**

```markdown
CPU通过总线与存储器或IO接口进行一次数据传输所需的时间
    | T1 | CPU往多路复用总线上发出地址信息，以指出寻址的存储单元或外设端口的地址
    | T2 | CPU从总线上撤销地址，使总线的低十六位为高阻态，为数据传输准备
    | T3 | 总线低十六位上出现由CPU写出的数据或者CPU从存储器或端口读入的数据
    | Tw | 一个或者多个，等待状态，等待外设或存储器的READY信号
    | T4 | 总线周期结束
空闲周期Ti，在一个总线周期结束后，若不执行下一个总线周期，则总线周期处于空闲状态
```



## **引脚信号与工作模式**

```markdown
| 最小工作模式 | 一个8086,总线控制信号都是8086发出
| 最大工作模式 | 多个处理器，主处理器：8086，协处理器：8087，8089等
```
### 引脚和信号
```markdown
引脚总数：20，双列直插封装

A,D复用——AD0..AD15

数据线——16位

    可用高八位传送一个字节
    可用低八位传送一个字节
    也可以用16位数据线传送一个字
    通过/BHE（BUS HIGH ENABLE）信号区分

RESET系统复位信号

READY

/RD：读

/WR：写

M//IO：区分CPU与内存之间传输数据还是CPU与IO接口传送数据

A/S：高四位地址和状态线复用

VCC:+5V

GND：地

AD[0..15]

    AD0信号可以作为低八位数据的选通信号
    CPU的传输特性决定了只要是和偶地址单元或偶地址端口交换数据，那么，CPU必定通过总线低八位传输数据

A19/S6A16/S3（输出）

    地址/状态复用引脚
    S6=0：8086当前与总线相连
    S5=1：允许可屏蔽中断请求
    S4与S3：指出当前正在使用哪个段寄存器

/BHE/S7：高八位数据允许总线/状态复用引脚（输出）

NMI:非屏蔽中断引脚（输入）

INTR:可屏蔽中断请求信号（输入）

    可屏蔽中断请求信号位高电平有效
    CPU在执行每条指令的最后一个时钟周期会对INTR信号进行采样，如果CPU的中断允许标志位（IF）为1，并且又接收到INTR信号，那么，CPU就会在结束当前指令后，响应中断请求，执行一个中断处理子程序。

/RD: 读信号（输出）

    指出将要执行对内存或IO端口的读操作
    与M/IO引脚信号配合，决定读取哪个设备

CLK：时钟（输入）

    8086要求：1/3周期为高电平（33%占空比）

RESET:复位信号（输入）

    至少维持四个时钟周期的高电平才有效

    复位执行的操作是

        CS：设置为FFFFH
        其他：清零

READY：准备好，输入

/TEST:输入

MN//MX:最小和最大模式控制信号，（输入）
```

### 最小工作模式

```markdown
/INTA:中断响应信号，输出

对外设的中断请求做出回应

ALE:地址锁存信号，输出

在任何一个总线周期的T1状态，ALE输出有效电平，以表示当前在地址/数据复用总线上输出的是地址信息，地址锁存器将ALE作为锁存信号，对地址进行锁存。

/DEN：数据允许信号，输出

表示CPU当前准备发送/接收一个数据

DT//R：数据收发信号，输出

M//IO

/WR：写，输出

HOLD:hold          request，总线保持请求信号

HLDA:hold          acknowledge 总线保持响应信号

```

### 最小工作模式下的典型配置

``` mark


锁存芯片——8282或者74ls373
数据总线驱动芯片——8286
```



## **8086的操作和时序**

### 复位

``` markdown
RESET：CPU将CS设置为初值为0FFFFH，其他内部寄存器设置为0
CS被初始化为FFFFH，IP被初始化为0000F，那么复位之后，8086从FFF0H开始执行程序
```

### 总线操作
``` markdown
总线读操作和总线写操作
```
### 中断操作和中断系统

```markdown

8086可以处理256种不同的中断，中断类型号（0255）
```

#### 硬件中断——外部中断
```markdown
非屏蔽中断

    通过CPU的NMI引脚进入，不受中断允许标志IF的屏蔽
    整个系统种只能有一个非屏蔽中断

可屏蔽中断

    通过CPU的INTR引脚进入的，当IF=1时，可屏蔽中断才可以进入
```

#### 软件中断
```markdown
CPU根据某条指令或者软件对标志寄存器中某个标志的设置而产生的
```
#### 中断向量和中断向量表
```markdown

中断系统以位于内存0段的03FFH（01023D）区域中的中断向量表为基础，中断向量表中最多可以容纳256个中断向量

中断向量就是中断处理子程序的入口地址，每一个中断类型对应一个中断向量

一个中断向量占4个存储单元

    前(低位)
    
    | IPL |
    | IPH |
    | CSL |
    | CSH |
    
    后（高位）

256个中断的前5个（04号）中断是专用中断

431号中断为保留的中断

其余中断：用户自定义

```

### 8086的存储器编址和IO编址

#### 存储器编址

```markdown
20根地址线=1MB（2^20）的存储地址空间：（00000-FFFFFH）

寄存器不能直接对1MB的内存空间进行寻址，引入分段的概念

一个段最长64KB（2^16）

各段的地址分别由CS,DS,SS,ES给出，寄存器为16位

存储单元的物理地址：（5位）

段地址左移四位(从16位变成20位)再加16位的偏移量

偏移量又称有效地址：可以放在IP,SP,BP,SI,DI,BX中

8086运行过程中，物理地址的形成因操作而异

    | 取指令                       | CS+IP
    | 堆栈操作                     | SS+SP或者SS+BP
    | 往内存写数据或者从内存读数据   | DS+SI或DS+DI或DS+BX

存储器的操作数可以是一个字节，也可以是一个字

如果是字操作数，低位字节放在较低的地址单元，高位字节放在较高的地址单元
字的地址以低位地址来表示
```

#### 存储器编址的注意事项

```markdown
根据一个物理地址可以反推出多个段地址和偏移量的组合

CS,DS,SS,ES的空间大小为64KB.但是在实际应用中，这些段之间可以有相互覆盖的部分

存储器中有的区域的功能是固定的

    中断向量表:00000-003FFH
    单色显示器的显示缓冲区
    彩色显示器的显示缓冲区
    无条件转移指令
```
#### 奇地址和偶地址

### 8086的IO编址

``` markdown
8086允许有65536（64K）个8为的IO端口

两种编址方式
统一编址

    可以用访问存储器的指令来实现对IO端口的读写，不需要设置专用的IO指令

独立编址

    使用指令系统中的专用的IO指令
```

# 第三章 指令系统

## 寻址方式

寻址就是寻找操作数得来源

### 立即数寻址

```markdown
所调用得操作数就在指令中直接给出
一般用与对寄存器赋值
```

### 寄存器寻址

```

AX BX CX DX SI DI SP BP
对段寄存器不能直接赋值>
MOV AX,0FFFFH 
MOV DS, AX

```

### IO端口寻址


#### IO直接寻址
``` markdown
    IO端口的地址直接在指令中给出
    寻址范围：0-255（00-FFH）
````
#### IO间接寻址
``` markdown
    先把DX寄存器中设置好IO端口的地址，IO指令用DX用寄存器间接寻址
    寻址范围：0-655536（0-FFFFH）
```

### 存储器寻址

```markdown
存储器单元的地址由段基地址+偏移量组成
偏移量就是有效地址EA

有效地址EA = 基址 + 变址 * 比例因子 + 位移量
```



#### 1直接寻址

    存储单元的有效地址由指令直接给出
    MOV        AX,[1070H] ；将**段的1070H（4位）和1071H（4位）两单元的内容取到AX（16位）中
    MOV        AX,ES:[1000H]  ;(带超越前缀)

#### 2寄存器间接寻址

```markdown
存储单元的有效地址由寄存器指出
MOV AX,[BX]
MOV CX,ES:[BX]

默认
SS:BP


DS:SI
DS:DI
DS:BX
```

#### 3寄存器相对寻址

    带位移量的寄存器相对寻址
    MOV AX,[BX+100H]
    寄存器的相对寻址常用做表格处理：将表格的首地址作为位移量，通过修改寄存器的内容指向表格的某一项

#### 4基址+变址的寻址

    基址寄存器BX,BP
    变址寄存器SI,DI
    段地址寄存器为DS时基址寄存器用BX
    段地址寄存器位SS时基址寄存器用BP
    
    当基址寄存器为BX时，段寄存器使用DS，当基址寄存器为BP时，段寄存器用SS。
    
    MOV AX,[BX+SI]
    MOV AX,[BX+DI]
    MOV AX,[BP+SI]
    MOV AX,[BP+DI]
    等价写法：MOV AX,[BX+SI]=======MOV AX,[BX][SI]

#### 5相对的基址+变址寻址

	带有位移量的基址+变址寻址
	MOV AX,[BX+SI+0050H]

#### 6相对的带比例因子的变址寻址（8086没有此功能）

	MOV BX,[SI*4+7]

#### 7基址+比例因子的变址寻址（8086没有此功能）

#### 8相对的基址+比例因子的寻址（8086没有此功能）


## 指令系统

### 传送指令

```markdown
CPU的内存寄存器之间，CPU和存储器之间，CPU和IO端口之间的数据交换


MOV：两操作数的位数相同

    | MOV AL,BL               | 8位的数据从BL送到AL 
    | MOV ES,DX               | 16位的数据从DX从到段寄存器ES中
    | MOV AX,[BX]             | 寄存器寻址方式：间接寻址！BX寄存器中存储的是某个存储单元的偏移地址(eg:1070H)，假设地址为1070H的存储单元中的内容是12H，假设地址为1071H的存储单元中的内容是34H，[BX]的意思时是，取出1070H和1071H这两个存储单元中所存储的内容，也就是1234H，然后MOV，AX,[BX]的意思也就是把取出来的值赋给AX，因此AX中存放的值就是1234H
    | MOV [DI],AX             | 假如AX中的值是1234H，I的值是1070H，那么意思就是，把1234H放到两个偏移地址分别是1070H和1071H的内存单元中，偏移地址为1070H的内存单元中的值是34，偏移地址为1071H的内存单元中的值是12
    | MOV DI,[BX]             |
    | MOV CX,[1000H]          | 
    | MOV WORD PTR [SI],1234H |
    | MOV DX,5040H            | 立即数送到DX

    MOVZX,MOVSX:两操作数的位数不相同

注意

    CS,IP寄存器不能作为目的操作数
    SI,DI来间接寻址时，默认的段寄存器为DS
    BP,SP来间接寻址时，默认的段寄存器为SS

```


### 堆栈指令

```markdown
PUSH：把一个2字节或者4字节的数据推入堆栈

POP:

    | PUSH BX                | 将BX的内容推入堆栈，堆栈指针减2
    | PUSH [BX+DI]           | 把BX+DI和BX+DI+1所指的两内存单元的值压入堆栈
    | PUSH 0870H             | 把立即数压栈
    | PUSH DWORD PTR [BX+SI] | 双字压栈
    | POP BX                 | 栈顶两单元弹出送给BX，栈顶地址+2

```
### 交换指令

```markdown
XCHG：字节，字，双字的交换

实现通用寄存器之间，通用寄存器和存储单元之间，不能在两存储单元之间

    | XCHG AL,BL     |
    | XCHG BX,CX     |
    | XCHG [2530],CX |
```
### 输入输出指令

```markdown
在主机和外部设备之间传送信息时，用输入输出指令

寻址方式

    | 直接的IO指令  | 在指令中直接提供了IO端口号码(寻址范围0255)
    | IN AL,50H    | 把端口50H的内容读入AL
    | IN AX,70H    | 把端口70H的内容读入AL，把端口71H的内容读入AH
    | OUT 80H,AX   | 把AL的内容输出到端口80H，把AH的内容输出到端口81H
    | 间接的IO指令  | 用寄存器DX设置端口号（寻址范围065536）
    | IN AL,DX     | （DX式唯一的，其他的都不可以）
    | IN AX,DX     |
    | OUT DX,AL    |
    | OUT DX,AX    |

```
### 换码指令

```markdown
XLAT:将累加器中的一个值变换成内存表格中的某一个值，一般用来实现编码制的转换
```

### 地址传送指令

```markdown
LEA:取有效地址：将存储器的有效地址送到一个寄存器，常用来使一个寄存器作为地址指针

    | LEA AX,[3820H]          | AX=3820H
    | LEA BX,[BP+SI]          | BX=BP+SI
    | LEA BX,[BP+SI+10H]      | BX=BP+SI+10H
    | LDS DI,[2530H]          | 把2530H，2531H的16位偏移量送到DI，把2532H，2533H的16位段码送到DS

```

### 标志传送指令

```markdown
| LAHF | 将标志寄存器中的低八位传送到AH中
| SAHF | 将AH中的内容送到标志寄存器的低八位
```

### 算数运算指令

```markdown
加法

    | ADD  | 不带进位ADD CX,1000H
    | ADC  | 带进位
    | INC  | a++ INC不会影响CF，即使用INC不会产生进位

减法

    | SUB  | 不考虑借位
    | SBB  | 考虑借位
    | DEC  | a--
    | NEG  | 求补
    | CMP  | 比较指令：执行两个数相减但不送回相减的结果，只影响结果的标志位

乘法（和AX或AL进行运算，隐含寻址）

    | MUL  | 无符号数的乘法 |
    | IMUL | 有符号数的乘法 |

除法（和AX或AL进行运算，隐含寻址）

    | DIV  | 无符号数的除法 |
    | IDIV | 有符号数的除法 |

类型转换

    | CBW  | 字节转换成字 |
    | CWD  | 字转换成双字 |

BCD码
	BCD码加法十进制调整指令
        AAA:用与两个非组合的BCD码相加进行调整，产生有个非组合的BCD码
        DAA:用与两个组合的BCD码相加结果进行调整，产生一个组合的BCD码
        
        MOV AL,37H
        MOV BL,35H
        ADD AL,BL ;两个16进制数相加，AL此时为37H+35H=6C
        DAA ;DAA调整，这时AL为72H。
        
        组合BCD码是通常的8421码，它用4个二进制位表示一个十进制位，一个字节可以表示两个十进制位，即00~99。
        MOV AL，68H ；AL=68H，表示压缩BCD码68
        MOV BL，28H ；BL=28H；表示压缩BCD码28
        ADD AL，BL ；二进制加法：AL=68H+28H=90H
        DAA ； 十进制调整：AL=96H

        非组合BCD码用8个二进制位表示一个十进制位，实际上只是用低4个二进制位表示一个十进制位0~9，高4位任意，但通常默认为0。ASCII码中0~9的编码是30H~39H，所以0~9的ASCII码（高4位变为0）就可以认为是非压缩BCD码。
        MOV AX，0608H ；AX=0608H，表示非压缩BCD码68
        MOV BL，09H ；BL=09H，表示非压缩BCD码9
        ADD AL，BL ；二进制加法：AL=08H+09=11H
        AAA ；十进制调整：AX=0707H
    ------------------------------------------------------------------------
	减法
	AAS  非组合
	
	DAS  组合
	------------------------------------------------------------------------
	AAM 乘法
	
	AAD  除法
	
	
```



### 逻辑运算和移位

```markdown
逻辑运算

    | AND  | 与 AND AX,1000H，结果放到AX
    | OR   | 或 OR AX,1000H，结果放到AX
    | NOT  | 非 NOT AX，结果放到AX，非运算的操作数不能是立即数
    | XOR  | 异或 XOR AX，1000H，结果放到AX
    | TEST | 测试：TEST AL,01H，进行与计算，但是不送回结果，仅改变标志位


移位
    移动一位时，由指令直接给出；移动两位及以上，则移动次数由CL指定
非循环移位指令

    | SAL  | 算数左移 |
    | SHL  | 逻辑左移 |
    | SAR  | 算数右移 |
    | SHR  | 算数右移 |


循环移位指令

    | ROL  | 不带进位的循环左移 |
    | ROR  | 不带进位的循环右移 |
    | RCL  | 带进位的循环左移   |
    | RCR  | 带进位的循环右移   |
```

### 串操作

```markdown

    | 源串一般放在数据段，偏移地址由SI指定 目标串一般放在附加段，偏移地址由DI指定
    | 指令自动修改地址指针，修改方向由DF指定
    | 数据块长度由CX指定
    | CLD与STD是用来操作方向标志位DF（Direction Flag）。CLD使DF复位，即DF=0，STD使DF置位，即DF=1.用于串操作指令中。

重复前缀指令

    | REP   | 无条件重复 |
    | REPE  | 相等重复   |
    | REPZ  | 为零重复   |
    | REPNE | 不相等重复 |
    | REPNZ | 不为零重复 |

    | 字符串传送指令：MOVS
    | 字符串比较指令： COMPS
    | 字符串检索指令：SCAS
    | 取字符串：LODS
    | 存字符串：STOS

IO串操作
```

### 调用，转移，循环，中断

```markdown
转移和调用
    段内直接转移方式
    段内间接转移方式
    段间直接转移方式
    段间间接寻址方式
子程序调用和返回

    CALL
        | CALL 1000H         | 段内直接调用 |
        | CALL AX            | 段内间接调用 |
        | CALL 2500H:3600H   | 段间直接调用 |
        | CALL DWORD PTR[DI] | 段间间接调用 |
    RET

无条件转移和条件转移

    | 无条件转移指令 ： JMP
    | 条件转移指令：
    				JE/JZ  	结果为0则转移
    				JNE/JNZ	结果不为0
    				JG/JNLE 大于（有符号数）
    				JNG/JLE	不大于（有符号数）
    				JL/JNGE	小于（有符号数）
    				JNL/JGE	不小于（有符号数）
    				JB/JNAE 低于（无符号数）
    				JNB/JAE	不低于（无符号数）
    				JA/JNBE	高于（无符号数）
    				JNA/JBE	不高于（无符号数）

循环

    | LOOP   | 
      loop指令的格式是：loop标号，cpu执行loop指令的时候，要进行两步操作
             1：（cx）=（cx）-1   
            2：判断cx中的值，不为零则转至标号处执行，如果为零，则向下执行
    | LOOPZ  |
    | LOOPNZ |

中断

    | INT n      | 执行中断类型n的中断服务程序 |
    | INT0       | 执行溢出中断的中断服务程序  |
    | IRET/IRETD | 从中断服务程序返回调用程序  |

中断指令的执行过程
    将FLAGS压入堆栈；
    将INT指令的下一条指令的CS,IP压栈
    由n*4得到存放中断向量表的地址
    将中断向量（中断服务程序入口地址）送CS和IP寄存器
    转入中断服务程序
    
    IRET 是中断服务子程序的返回指令。
	用于从中断返回， 等价于
	POP CS
	POP IP
	POPF（标志传送指令（标志位出栈指令） POPF）
```

### 标志操作和处理器控制

```markdown
标志操作
暂停指令
交权，等待
总线封锁
```

### 汇编


#### 标记
```markdown
标识符
保留字
分界符
常数
```
#### 表达式
```markdown
操作数

运算符

    算数运算符：+*/和MOD

    逻辑运算符：AND OR NOT XOR

    关系运算符：EQ NE LT GT LE GE

分析运算符

    OFFSET：取存储单元地址的偏移量
    SGE:取存储单元地址的断码
    
    MOV SI,OFFSET BUFFER
    MOV DX,SEG BUFFER
    
    LEA AX,BUFFER

综合运算符

    PTR:用来对存储单元规定类型，通常和后面讲述的伪指令BYTE,WORD,DWORD等连用
    
	MOV BYTE PTR[1000],0
	MOV WORD PTR[1000],0
	MOV DWORD PTR[1000],0
	
	
```
#### 语句

```markdown
- 指令性语句 标志性语句
- 一条指令性语句实际上就是一条指令
- 指示性语句也叫伪指令
- 每条指令性语句在汇编过程中都会产生对应的目标代码
- 指示性语句为汇编程序提供某些信息，让汇编程序在汇编过程中执行某些特定的功能
```



#### 伪指令

```markdown
标号赋值伪指令
	EQU
	MAXNUM EQU 200 

定义存储单元的伪指令：

    | DB   | 字节     | AA DB 0AH
    | DW   | 字       | BB DW 10 DUP(?) 
    | DD   | 双字     |
    | DQ   | 四字     |
    | DT   | 10个字节 |

定义存储单元类型的伪指令：必须与PTR配合使用

    | BYTE  | BYTE PTR  |
    | WORD  | WORD PTR  |
    | DWORD | DWORD PTR |

段定义伪指令

    | SEGMENT |
    | ENDS    |
    | ASSUME  | 告诉汇编程序，哪个段为数据段，哪个段为堆栈段，哪个段为代码段
    | ORG     | 用来规定目标程序存放单元的偏移量   ORG  2000H

简约段定义伪指令

定义过程的伪指令

    | PROC | 子程序
    | ENDP | 
    | NEAR | 段内调用 
    | FAR  | 段间调用

源程序结束伪指令

    | END  | 源程序的结束标志 |
```